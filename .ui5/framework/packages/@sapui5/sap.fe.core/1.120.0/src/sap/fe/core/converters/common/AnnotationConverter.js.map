{"version":3,"file":"AnnotationConverter.js","names":["VocabularyReferences_1","__webpack_require__","utils_1","ANNOTATION_TARGET","Symbol","appendObjectPath","objectPath","visitedObject","length","push","resolveTarget","converter","startElement","path","annotationsTerm","undefined","target","messages","startsWith","substring","pathSegments","split","reduce","targetPath","segment","includes","pathPart","annotationPart","splitAtFirst","rawSchema","namespace","_a","getConvertedEntityContainer","fullyQualifiedName","_c","_b","getConvertedEntityType","getConvertedComplexType","getConvertedAction","shift","_type","parentElementFQN","substringBeforeFirst","_d","result","current","error","message","vocabularyAlias","term","splitTerm","annotation","annotations","$target","subPath","value","subTarget","forEach","visitedSubObject","thisElement","unalias","nextElement","entitySets","by_name","singletons","actionImports","entityType","navigationPropertyBindings","navigationPropertyBinding","property","entityProperties","navigationProperty","navigationProperties","actionName","action","actions","isBound","parameters","_e","find","param","name","type","targetType","properties","referencedType","typeReference","logError","annotationType","inferTypeFromTerm","isAnnotationPath","pathStr","mapPropertyPath","propertyPath","currentTarget","currentTerm","PropertyPath","lazy","mapAnnotationPath","annotationPath","AnnotationPath","mapNavigationPropertyPath","navigationPropertyPath","NavigationPropertyPath","mapPath","Path","getValue","parseValue","currentProperty","currentSource","propertyValue","valueFQN","String","Int","Bool","Decimal","Date","splitEnum","EnumMember","map","enumValue","unaliased","alias","VocabularyReferences","EnumIsFlag","parseRecord","Record","parseCollection","Collection","annotationTarget","TermToTypes","substringBeforeLast","isDataFieldWithForAction","annotationContent","hasOwnProperty","$Type","parseRecordType","recordDefinition","annotationRecord","currentFQN","record","__source","propertyValues","resolveAnnotationsOnAnnotation","Action","toString","actionTarget","getConvertedActionImport","getOrInferCollectionType","collectionDefinition","firstColItem","parentFQN","collectionDefinitionType","index","pathValue","recordIdx","ifValue","stringValue","Error","isV4NavigationProperty","navProp","targetTypeName","convertAnnotation","rawAnnotation","collection","Boolean","Number","vocAlias","vocTerm","qualifier","e","Converter","getAnnotations","this","annotationsByTarget","annotationSources","Object","keys","source","annotationList","mergeAnnotations","rawMetadata","references","getConvertedElement","schema","entityContainer","convertEntityContainer","getConvertedEntitySet","convertedOutput","by_fullyQualifiedName","getConvertedSingleton","entityTypes","complexTypes","getConvertedTypeDefinition","typeDefinitions","actionImport","convert","rawValue","Array","isArray","converted","convertedElements","rawElement","convertedElement","addGetByValue","constructor","Map","get","apply","set","diagnostics","aliased","splitAtLast","resolveEntityType","resolveNavigationPropertyBindings","rawNavigationPropertyBindings","bindingPath","rawBindingTarget","resolveAnnotations","rawAnnotationTarget","nestedAnnotations","createAnnotationsObject","annotationTerm","rawAnnotations","vocabularyAliases","vocTermWithQualifier","rawEntityContainer","convertedEntityContainer","convertEntitySet","convertSingleton","convertActionImport","rawSingleton","convertedSingleton","entityTypeName","_rawNavigationPropertyBindings","rawEntitySet","convertedEntitySet","convertEntityType","rawEntityType","convertedEntityType","keyProp","isKey","convertProperty","convertNavigationProperty","filter","rawAction","sourceType","resolvePath","relativePath","includeVisitedObjects","resolved","visitedObjects","rawProperty","convertedProperty","typeName","rawNavigationProperty","convertedNavigationProperty","referentialConstraint","associationEnd","associations","association","relationship","end","role","toRole","isCollection","multiplicity","rawActionImport","convertedActionImport","rawActions","convertAction","convertedAction","returnType","convertActionParameter","unspecificOverloadTarget","specificOverloadTarget","effectiveAnnotations","unspecificAnnotations","unspecificAnnotation","some","rawActionParameter","convertedActionParameter","indexOf","convertComplexType","rawComplexType","convertedComplexType","convertTypeDefinition","rawTypeDefinition","convertedTypeDefinition","version","targetResolution","exports","__exportStar","EnumIsFlag_1","defineProperty","enumerable","TermToTypes_1","splitAt","string","substringAt","separator","lastIndexOf","unaliasedValue","reverseReferenceMap","ref","reference","preAlias","postAlias","aliasedValue","_unalias","referenceMap","fromEntries","maybeAlias","rest","isAnnotation","valueToUnalias","knownReference","segments","first","subSegment","parameter","slice","join","isComplexTypeDefinition","complexTypeDefinition","isDecimal","valueOf","object","init","initial","_value","createIndexedFind","array","element","indexName","writable","reduceRight","annotationsOnTarget","existingAnnotation","revertObjectToRawType","anno","revertCollectionItemToRawType","call","isString","valueMatches","isInt","isFloat","Float","isDate","_f","isBoolean","Apply","prototype","revertValueToRawType","valueConstructor","toFixed","restrictedKeys","revertAnnotationsToRawType","currentAnnotations","targetAnnotations","key","parsedAnnotation","revertTermToGenericType","unaliasedTerm","qualifiedSplit","collectionItem","outItem","collectionKey","baseAnnotation","uri","__webpack_module_cache__","moduleId","cachedModule","module","__webpack_modules__","__webpack_exports__"],"sources":["webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+annotation-converter@0.7.2/node_modules/@sap-ux/annotation-converter/src/converter.ts","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+annotation-converter@0.7.2/node_modules/@sap-ux/annotation-converter/src/index.ts","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+annotation-converter@0.7.2/node_modules/@sap-ux/annotation-converter/src/utils.ts","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+annotation-converter@0.7.2/node_modules/@sap-ux/annotation-converter/src/writeback.ts","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+vocabularies-types@0.9.1/node_modules/@sap-ux/vocabularies-types/vocabularies/EnumIsFlag.js","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+vocabularies-types@0.9.1/node_modules/@sap-ux/vocabularies-types/vocabularies/TermToTypes.js","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+vocabularies-types@0.9.1/node_modules/@sap-ux/vocabularies-types/vocabularies/VocabularyReferences.js","webpack://AnnotationConverter/webpack/bootstrap","webpack://AnnotationConverter/webpack/startup"],"sourcesContent":["import type {\n    Action,\n    ActionImport,\n    ActionParameter,\n    Annotation,\n    AnnotationPath,\n    AnnotationRecord,\n    ArrayWithIndex,\n    BaseNavigationProperty,\n    ComplexType,\n    ConvertedMetadata,\n    EntityContainer,\n    EntitySet,\n    EntityType,\n    Expression,\n    FullyQualifiedName,\n    NavigationProperty,\n    NavigationPropertyPath,\n    PathAnnotationExpression,\n    Property,\n    PropertyPath,\n    RawAction,\n    RawActionImport,\n    RawAnnotation,\n    RawComplexType,\n    RawEntityContainer,\n    RawEntitySet,\n    RawEntityType,\n    RawMetadata,\n    RawNavigationPropertyBinding,\n    RawProperty,\n    RawSchema,\n    RawSingleton,\n    RawTypeDefinition,\n    RawV2NavigationProperty,\n    RawV4NavigationProperty,\n    RemoveAnnotationAndType,\n    ResolutionTarget,\n    Singleton,\n    TypeDefinition\n} from '@sap-ux/vocabularies-types';\nimport { VocabularyReferences } from '@sap-ux/vocabularies-types/vocabularies/VocabularyReferences';\nimport {\n    addGetByValue,\n    alias,\n    Decimal,\n    EnumIsFlag,\n    lazy,\n    mergeAnnotations,\n    splitAtFirst,\n    splitAtLast,\n    substringBeforeFirst,\n    substringBeforeLast,\n    TermToTypes,\n    unalias\n} from './utils';\n\n/**\n * Symbol to extend an annotation with the reference to its target.\n */\nconst ANNOTATION_TARGET = Symbol('Annotation Target');\n\n/**\n * Append an object to the list of visited objects if it is different from the last object in the list.\n *\n * @param objectPath    The list of visited objects\n * @param visitedObject The object\n * @returns The list of visited objects\n */\nfunction appendObjectPath(objectPath: any[], visitedObject: any): any[] {\n    if (objectPath[objectPath.length - 1] !== visitedObject) {\n        objectPath.push(visitedObject);\n    }\n    return objectPath;\n}\n\n/**\n * Resolves a (possibly relative) path.\n *\n * @param converter         Converter\n * @param startElement      The starting point in case of relative path resolution\n * @param path              The path to resolve\n * @param annotationsTerm   Only for error reporting: The annotation term\n * @returns An object containing the resolved target and the elements that were visited while getting to the target.\n */\nfunction resolveTarget<T>(\n    converter: Converter,\n    startElement: any,\n    path: string | undefined,\n    annotationsTerm?: string\n): ResolutionTarget<T> {\n    if (path === undefined) {\n        return { target: undefined, objectPath: [], messages: [] };\n    }\n\n    // absolute paths always start at the entity container\n    if (path.startsWith('/')) {\n        path = path.substring(1);\n        startElement = undefined; // will resolve to the entity container (see below)\n    }\n\n    const pathSegments = path.split('/').reduce((targetPath, segment) => {\n        if (segment.includes('@')) {\n            // Separate out the annotation\n            const [pathPart, annotationPart] = splitAtFirst(segment, '@');\n            targetPath.push(pathPart);\n            targetPath.push(`@${annotationPart}`);\n        } else {\n            targetPath.push(segment);\n        }\n        return targetPath;\n    }, [] as string[]);\n\n    // determine the starting point for the resolution\n    if (startElement === undefined) {\n        // no starting point given: start at the entity container\n        if (\n            pathSegments[0].startsWith(`${converter.rawSchema.namespace}.`) &&\n            pathSegments[0] !== converter.getConvertedEntityContainer()?.fullyQualifiedName\n        ) {\n            // We have a fully qualified name in the path that is not the entity container.\n            startElement =\n                converter.getConvertedEntityType(pathSegments[0]) ??\n                converter.getConvertedComplexType(pathSegments[0]) ??\n                converter.getConvertedAction(pathSegments[0]);\n            pathSegments.shift(); // Let's remove the first path element\n        } else {\n            startElement = converter.getConvertedEntityContainer();\n        }\n    } else if (startElement[ANNOTATION_TARGET] !== undefined) {\n        // annotation: start at the annotation target\n        startElement = startElement[ANNOTATION_TARGET];\n    } else if (startElement._type === 'Property') {\n        // property: start at the entity type or complex type the property belongs to\n        const parentElementFQN = substringBeforeFirst(startElement.fullyQualifiedName, '/');\n        startElement =\n            converter.getConvertedEntityType(parentElementFQN) ?? converter.getConvertedComplexType(parentElementFQN);\n    }\n\n    const result = pathSegments.reduce(\n        (current: ResolutionTarget<any>, segment: string) => {\n            const error = (message: string) => {\n                current.messages.push({ message });\n                current.target = undefined;\n                return current;\n            };\n\n            if (current.target === undefined) {\n                return current;\n            }\n\n            current.objectPath = appendObjectPath(current.objectPath, current.target);\n\n            // Annotation\n            if (segment.startsWith('@') && segment !== '@$ui5.overload') {\n                const [vocabularyAlias, term] = converter.splitTerm(segment);\n                const annotation = current.target.annotations[vocabularyAlias.substring(1)]?.[term];\n\n                if (annotation !== undefined) {\n                    current.target = annotation;\n                    return current;\n                }\n                return error(\n                    `Annotation '${segment.substring(1)}' not found on ${current.target._type} '${\n                        current.target.fullyQualifiedName\n                    }'`\n                );\n            }\n\n            // $Path / $AnnotationPath syntax\n            if (current.target.$target) {\n                let subPath: string | undefined;\n                if (segment === '$AnnotationPath') {\n                    subPath = current.target.value;\n                } else if (segment === '$Path') {\n                    subPath = current.target.path;\n                }\n\n                if (subPath !== undefined) {\n                    const subTarget = resolveTarget(converter, current.target[ANNOTATION_TARGET], subPath);\n                    subTarget.objectPath.forEach((visitedSubObject: any) => {\n                        if (!current.objectPath.includes(visitedSubObject)) {\n                            current.objectPath = appendObjectPath(current.objectPath, visitedSubObject);\n                        }\n                    });\n\n                    current.target = subTarget.target;\n                    current.objectPath = appendObjectPath(current.objectPath, current.target);\n                    return current;\n                }\n            }\n\n            // traverse based on the element type\n            switch (current.target?._type) {\n                case 'Schema':\n                    // next element: EntityType, ComplexType, Action, EntityContainer ?\n\n                    break;\n                case 'EntityContainer':\n                    {\n                        const thisElement = current.target as EntityContainer;\n\n                        if (segment === '' || converter.unalias(segment) === thisElement.fullyQualifiedName) {\n                            return current;\n                        }\n\n                        // next element: EntitySet, Singleton or ActionImport?\n                        const nextElement: EntitySet | Singleton | ActionImport | undefined =\n                            thisElement.entitySets.by_name(segment) ??\n                            thisElement.singletons.by_name(segment) ??\n                            thisElement.actionImports.by_name(segment);\n\n                        if (nextElement) {\n                            current.target = nextElement;\n                            return current;\n                        }\n                    }\n                    break;\n\n                case 'EntitySet':\n                case 'Singleton': {\n                    const thisElement = current.target as EntitySet | Singleton;\n\n                    if (segment === '' || segment === '$Type') {\n                        // Empty Path after an EntitySet or Singleton means EntityType\n                        current.target = thisElement.entityType;\n                        return current;\n                    }\n\n                    if (segment === '$') {\n                        return current;\n                    }\n\n                    if (segment === '$NavigationPropertyBinding') {\n                        const navigationPropertyBindings = thisElement.navigationPropertyBinding;\n                        current.target = navigationPropertyBindings;\n                        return current;\n                    }\n\n                    // continue resolving at the EntitySet's or Singleton's type\n                    const result = resolveTarget(converter, thisElement.entityType, segment);\n                    current.target = result.target;\n                    current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);\n                    return current;\n                }\n\n                case 'EntityType':\n                    {\n                        const thisElement = current.target as EntityType;\n\n                        if (segment === '' || segment === '$Type') {\n                            return current;\n                        }\n\n                        const property = thisElement.entityProperties.by_name(segment);\n                        if (property) {\n                            current.target = property;\n                            return current;\n                        }\n\n                        const navigationProperty = thisElement.navigationProperties.by_name(segment);\n                        if (navigationProperty) {\n                            current.target = navigationProperty;\n                            return current;\n                        }\n\n                        const actionName = substringBeforeFirst(converter.unalias(segment), '(');\n                        const action = thisElement.actions[actionName];\n                        if (action) {\n                            current.target = action;\n                            return current;\n                        }\n                    }\n                    break;\n\n                case 'ActionImport': {\n                    // continue resolving at the Action\n                    const result = resolveTarget(converter, current.target.action, segment);\n                    current.target = result.target;\n                    current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);\n                    return current;\n                }\n\n                case 'Action': {\n                    const thisElement = current.target as Action;\n\n                    if (segment === '') {\n                        return current;\n                    }\n\n                    if (segment === '@$ui5.overload' || segment === '0') {\n                        return current;\n                    }\n\n                    if (segment === '$Parameter' && thisElement.isBound) {\n                        current.target = thisElement.parameters;\n                        return current;\n                    }\n\n                    const nextElement =\n                        thisElement.parameters[segment as any] ??\n                        thisElement.parameters.find((param: ActionParameter) => param.name === segment);\n\n                    if (nextElement) {\n                        current.target = nextElement;\n                        return current;\n                    }\n                    break;\n                }\n\n                case 'Property':\n                    {\n                        const thisElement = current.target as Property;\n\n                        // Property or NavigationProperty of the ComplexType\n                        const type = thisElement.targetType as ComplexType | undefined;\n                        if (type !== undefined) {\n                            const property = type.properties.by_name(segment);\n                            if (property) {\n                                current.target = property;\n                                return current;\n                            }\n\n                            const navigationProperty = type.navigationProperties.by_name(segment);\n                            if (navigationProperty) {\n                                current.target = navigationProperty;\n                                return current;\n                            }\n                        }\n                    }\n                    break;\n\n                case 'ActionParameter':\n                    const referencedType = (current.target as ActionParameter).typeReference;\n                    if (referencedType !== undefined) {\n                        const result = resolveTarget(converter, referencedType, segment);\n                        current.target = result.target;\n                        current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);\n                        return current;\n                    }\n                    break;\n\n                case 'NavigationProperty':\n                    // continue at the NavigationProperty's target type\n                    const result = resolveTarget(converter, (current.target as NavigationProperty).targetType, segment);\n                    current.target = result.target;\n                    current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);\n                    return current;\n\n                default:\n                    if (segment === '') {\n                        return current;\n                    }\n\n                    if (current.target[segment]) {\n                        current.target = current.target[segment];\n                        current.objectPath = appendObjectPath(current.objectPath, current.target);\n                        return current;\n                    }\n            }\n\n            return error(\n                `Element '${segment}' not found at ${current.target._type} '${current.target.fullyQualifiedName}'`\n            );\n        },\n        { target: startElement, objectPath: [], messages: [] }\n    );\n\n    // Diagnostics\n    result.messages.forEach((message) => converter.logError(message.message));\n    if (!result.target) {\n        if (annotationsTerm) {\n            const annotationType = inferTypeFromTerm(converter, annotationsTerm, startElement.fullyQualifiedName);\n            converter.logError(\n                'Unable to resolve the path expression: ' +\n                    '\\n' +\n                    path +\n                    '\\n' +\n                    '\\n' +\n                    'Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \\n\\n' +\n                    '<Annotation Term = ' +\n                    annotationsTerm +\n                    '>' +\n                    '\\n' +\n                    '<Record Type = ' +\n                    annotationType +\n                    '>' +\n                    '\\n' +\n                    '<AnnotationPath = ' +\n                    path +\n                    '>'\n            );\n        } else {\n            converter.logError(\n                'Unable to resolve the path expression: ' +\n                    path +\n                    '\\n' +\n                    '\\n' +\n                    'Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \\n\\n' +\n                    '<Annotation Term = ' +\n                    pathSegments[0] +\n                    '>' +\n                    '\\n' +\n                    '<PropertyValue  Path= ' +\n                    pathSegments[1] +\n                    '>'\n            );\n        }\n    }\n\n    return result;\n}\n\n/**\n * Typeguard to check if the path contains an annotation.\n *\n * @param pathStr the path to evaluate\n * @returns true if there is an annotation in the path.\n */\nfunction isAnnotationPath(pathStr: string): boolean {\n    return pathStr.includes('@');\n}\n\ntype AnnotationValue<T> = T & { [ANNOTATION_TARGET]: any };\n\nfunction mapPropertyPath(\n    converter: Converter,\n    propertyPath: { type: 'PropertyPath'; PropertyPath: string },\n    fullyQualifiedName: FullyQualifiedName,\n    currentTarget: any,\n    currentTerm: string\n) {\n    const result: Omit<AnnotationValue<PropertyPath>, '$target'> = {\n        type: 'PropertyPath',\n        value: propertyPath.PropertyPath,\n        fullyQualifiedName: fullyQualifiedName,\n        [ANNOTATION_TARGET]: currentTarget\n    };\n\n    lazy(\n        result as AnnotationValue<PropertyPath>,\n        '$target',\n        () => resolveTarget<Property>(converter, currentTarget, propertyPath.PropertyPath, currentTerm).target\n    );\n\n    return result as AnnotationValue<PropertyPath>;\n}\n\nfunction mapAnnotationPath(\n    converter: Converter,\n    annotationPath: { type: 'AnnotationPath'; AnnotationPath: string },\n    fullyQualifiedName: FullyQualifiedName,\n    currentTarget: any,\n    currentTerm: string\n) {\n    const result: Omit<AnnotationValue<AnnotationPath<any>>, '$target'> = {\n        type: 'AnnotationPath',\n        value: converter.unalias(annotationPath.AnnotationPath),\n        fullyQualifiedName: fullyQualifiedName,\n        [ANNOTATION_TARGET]: currentTarget\n    };\n\n    lazy(\n        result as AnnotationValue<AnnotationPath<any>>,\n        '$target',\n        () => resolveTarget(converter, currentTarget, result.value, currentTerm).target\n    );\n\n    return result as AnnotationValue<AnnotationPath<any>>;\n}\n\nfunction mapNavigationPropertyPath(\n    converter: Converter,\n    navigationPropertyPath: { type: 'NavigationPropertyPath'; NavigationPropertyPath: string },\n    fullyQualifiedName: FullyQualifiedName,\n    currentTarget: any,\n    currentTerm: string\n) {\n    const result: Omit<AnnotationValue<NavigationPropertyPath>, '$target'> = {\n        type: 'NavigationPropertyPath',\n        value: navigationPropertyPath.NavigationPropertyPath ?? '',\n        fullyQualifiedName: fullyQualifiedName,\n        [ANNOTATION_TARGET]: currentTarget\n    };\n\n    lazy(\n        result as AnnotationValue<NavigationPropertyPath>,\n        '$target',\n        () =>\n            resolveTarget<NavigationProperty>(\n                converter,\n                currentTarget,\n                navigationPropertyPath.NavigationPropertyPath,\n                currentTerm\n            ).target\n    );\n\n    return result as AnnotationValue<NavigationPropertyPath>;\n}\n\nfunction mapPath(\n    converter: Converter,\n    path: { type: 'Path'; Path: string },\n    fullyQualifiedName: FullyQualifiedName,\n    currentTarget: any,\n    currentTerm: string\n) {\n    const result: Omit<AnnotationValue<PathAnnotationExpression<any>>, '$target'> = {\n        type: 'Path',\n        path: path.Path,\n        fullyQualifiedName: fullyQualifiedName,\n        getValue(): any {\n            return undefined; // TODO: Required according to the type...\n        },\n        [ANNOTATION_TARGET]: currentTarget\n    };\n\n    lazy(\n        result as AnnotationValue<PathAnnotationExpression<any>>,\n        '$target',\n        () => resolveTarget<Property>(converter, currentTarget, path.Path, currentTerm).target\n    );\n\n    return result as AnnotationValue<PathAnnotationExpression<any>>;\n}\n\nfunction parseValue(\n    converter: Converter,\n    currentTarget: any,\n    currentTerm: string,\n    currentProperty: string,\n    currentSource: string,\n    propertyValue: Expression,\n    valueFQN: string\n) {\n    if (propertyValue === undefined) {\n        return undefined;\n    }\n    switch (propertyValue.type) {\n        case 'String':\n            return propertyValue.String;\n        case 'Int':\n            return propertyValue.Int;\n        case 'Bool':\n            return propertyValue.Bool;\n        case 'Decimal':\n            return Decimal(propertyValue.Decimal);\n        case 'Date':\n            return propertyValue.Date;\n        case 'EnumMember':\n            const splitEnum = propertyValue.EnumMember.split(' ').map((enumValue) => {\n                const unaliased = converter.unalias(enumValue) ?? '';\n                return alias(VocabularyReferences, unaliased);\n            });\n            if (splitEnum[0] !== undefined && EnumIsFlag[substringBeforeFirst(splitEnum[0], '/')]) {\n                return splitEnum;\n            }\n            return splitEnum[0];\n\n        case 'PropertyPath':\n            return mapPropertyPath(converter, propertyValue, valueFQN, currentTarget, currentTerm);\n\n        case 'NavigationPropertyPath':\n            return mapNavigationPropertyPath(converter, propertyValue, valueFQN, currentTarget, currentTerm);\n\n        case 'AnnotationPath':\n            return mapAnnotationPath(converter, propertyValue, valueFQN, currentTarget, currentTerm);\n\n        case 'Path': {\n            if (isAnnotationPath(propertyValue.Path)) {\n                // inline the target\n                return resolveTarget(converter, currentTarget, propertyValue.Path, currentTerm).target;\n            } else {\n                return mapPath(converter, propertyValue, valueFQN, currentTarget, currentTerm);\n            }\n        }\n\n        case 'Record':\n            return parseRecord(\n                converter,\n                currentTerm,\n                currentTarget,\n                currentProperty,\n                currentSource,\n                propertyValue.Record,\n                valueFQN\n            );\n\n        case 'Collection':\n            return parseCollection(\n                converter,\n                currentTarget,\n                currentTerm,\n                currentProperty,\n                currentSource,\n                propertyValue.Collection,\n                valueFQN\n            );\n        case 'Apply':\n        case 'Null':\n        case 'Not':\n        case 'Eq':\n        case 'Ne':\n        case 'Gt':\n        case 'Ge':\n        case 'Lt':\n        case 'Le':\n        case 'If':\n        case 'And':\n        case 'Or':\n        default:\n            return propertyValue;\n    }\n}\n\n/**\n * Infer the type of a term based on its type.\n *\n * @param converter         Converter\n * @param annotationsTerm   The annotation term\n * @param annotationTarget  The annotation target\n * @param currentProperty   The current property of the record\n * @returns The inferred type.\n */\nfunction inferTypeFromTerm(\n    converter: Converter,\n    annotationsTerm: string,\n    annotationTarget: string,\n    currentProperty?: string\n) {\n    let targetType = (TermToTypes as any)[annotationsTerm];\n    if (currentProperty) {\n        annotationsTerm = `${substringBeforeLast(annotationsTerm, '.')}.${currentProperty}`;\n        targetType = (TermToTypes as any)[annotationsTerm];\n    }\n\n    converter.logError(\n        `The type of the record used within the term ${annotationsTerm} was not defined and was inferred as ${targetType}.\nHint: If possible, try to maintain the Type property for each Record.\n<Annotations Target=\"${annotationTarget}\">\n\t<Annotation Term=\"${annotationsTerm}\">\n\t\t<Record>...</Record>\n\t</Annotation>\n</Annotations>`\n    );\n\n    return targetType;\n}\n\nfunction isDataFieldWithForAction(annotationContent: any) {\n    return (\n        annotationContent.hasOwnProperty('Action') &&\n        (annotationContent.$Type === 'com.sap.vocabularies.UI.v1.DataFieldForAction' ||\n            annotationContent.$Type === 'com.sap.vocabularies.UI.v1.DataFieldWithAction')\n    );\n}\n\nfunction parseRecordType(\n    converter: Converter,\n    currentTerm: string,\n    currentTarget: any,\n    currentProperty: string | undefined,\n    recordDefinition: AnnotationRecord\n) {\n    let targetType;\n    if (!recordDefinition.type && currentTerm) {\n        targetType = inferTypeFromTerm(converter, currentTerm, currentTarget.fullyQualifiedName, currentProperty);\n    } else {\n        targetType = converter.unalias(recordDefinition.type);\n    }\n    return targetType;\n}\n\nfunction parseRecord(\n    converter: Converter,\n    currentTerm: string,\n    currentTarget: any,\n    currentProperty: string | undefined,\n    currentSource: string,\n    annotationRecord: AnnotationRecord,\n    currentFQN: string\n) {\n    const record: any = {\n        $Type: parseRecordType(converter, currentTerm, currentTarget, currentProperty, annotationRecord),\n        fullyQualifiedName: currentFQN,\n        [ANNOTATION_TARGET]: currentTarget,\n        __source: currentSource\n    };\n\n    for (const propertyValue of annotationRecord.propertyValues) {\n        lazy(record, propertyValue.name, () =>\n            parseValue(\n                converter,\n                currentTarget,\n                currentTerm,\n                propertyValue.name,\n                currentSource,\n                propertyValue.value,\n                `${currentFQN}/${propertyValue.name}`\n            )\n        );\n    }\n\n    // annotations on the record\n    lazy(record, 'annotations', resolveAnnotationsOnAnnotation(converter, annotationRecord, record));\n\n    if (isDataFieldWithForAction(record)) {\n        lazy(record, 'ActionTarget', () => {\n            const actionName = converter.unalias(record.Action?.toString());\n\n            // (1) Bound action of the annotation target?\n            let actionTarget = currentTarget.actions[actionName];\n\n            if (!actionTarget) {\n                // (2) ActionImport (= unbound action)?\n                actionTarget = converter.getConvertedActionImport(actionName)?.action;\n            }\n\n            if (!actionTarget) {\n                // (3) Bound action of a different EntityType (the actionName is fully qualified in this case)\n                actionTarget = converter.getConvertedAction(actionName);\n                if (!actionTarget?.isBound) {\n                    actionTarget = undefined;\n                }\n            }\n\n            if (!actionTarget) {\n                converter.logError(\n                    `${record.fullyQualifiedName}: Unable to resolve '${record.Action}' ('${actionName}')`\n                );\n            }\n            return actionTarget;\n        });\n    }\n    return record;\n}\n\nexport type CollectionType =\n    | 'PropertyPath'\n    | 'Path'\n    | 'If'\n    | 'Apply'\n    | 'Null'\n    | 'And'\n    | 'Eq'\n    | 'Ne'\n    | 'Not'\n    | 'Gt'\n    | 'Ge'\n    | 'Lt'\n    | 'Le'\n    | 'Or'\n    | 'AnnotationPath'\n    | 'NavigationPropertyPath'\n    | 'Record'\n    | 'String'\n    | 'EmptyCollection';\n\n/**\n * Retrieve or infer the collection type based on its content.\n *\n * @param collectionDefinition\n * @returns the type of the collection\n */\nfunction getOrInferCollectionType(collectionDefinition: any[]): CollectionType {\n    let type: CollectionType = (collectionDefinition as any).type;\n    if (type === undefined && collectionDefinition.length > 0) {\n        const firstColItem = collectionDefinition[0];\n        if (firstColItem.hasOwnProperty('PropertyPath')) {\n            type = 'PropertyPath';\n        } else if (firstColItem.hasOwnProperty('Path')) {\n            type = 'Path';\n        } else if (firstColItem.hasOwnProperty('AnnotationPath')) {\n            type = 'AnnotationPath';\n        } else if (firstColItem.hasOwnProperty('NavigationPropertyPath')) {\n            type = 'NavigationPropertyPath';\n        } else if (\n            typeof firstColItem === 'object' &&\n            (firstColItem.hasOwnProperty('type') || firstColItem.hasOwnProperty('propertyValues'))\n        ) {\n            type = 'Record';\n        } else if (typeof firstColItem === 'string') {\n            type = 'String';\n        }\n    } else if (type === undefined) {\n        type = 'EmptyCollection';\n    }\n    return type;\n}\n\nfunction parseCollection(\n    converter: Converter,\n    currentTarget: any,\n    currentTerm: string,\n    currentProperty: string,\n    currentSource: string,\n    collectionDefinition: any[],\n    parentFQN: string\n) {\n    const collectionDefinitionType = getOrInferCollectionType(collectionDefinition);\n\n    switch (collectionDefinitionType) {\n        case 'PropertyPath':\n            return collectionDefinition.map((path, index) =>\n                mapPropertyPath(converter, path, `${parentFQN}/${index}`, currentTarget, currentTerm)\n            );\n\n        case 'Path':\n            // TODO: make lazy?\n            return collectionDefinition.map((pathValue) => {\n                return resolveTarget(converter, currentTarget, pathValue.Path, currentTerm).target;\n            });\n\n        case 'AnnotationPath':\n            return collectionDefinition.map((path, index) =>\n                mapAnnotationPath(converter, path, `${parentFQN}/${index}`, currentTarget, currentTerm)\n            );\n\n        case 'NavigationPropertyPath':\n            return collectionDefinition.map((path, index) =>\n                mapNavigationPropertyPath(converter, path, `${parentFQN}/${index}`, currentTarget, currentTerm)\n            );\n\n        case 'Record':\n            return collectionDefinition.map((recordDefinition, recordIdx) => {\n                return parseRecord(\n                    converter,\n                    currentTerm,\n                    currentTarget,\n                    currentProperty,\n                    currentSource,\n                    recordDefinition,\n                    `${parentFQN}/${recordIdx}`\n                );\n            });\n\n        case 'Apply':\n        case 'Null':\n        case 'If':\n        case 'Eq':\n        case 'Ne':\n        case 'Lt':\n        case 'Gt':\n        case 'Le':\n        case 'Ge':\n        case 'Not':\n        case 'And':\n        case 'Or':\n            return collectionDefinition.map((ifValue) => ifValue);\n\n        case 'String':\n            return collectionDefinition.map((stringValue) => {\n                if (typeof stringValue === 'string' || stringValue === undefined) {\n                    return stringValue;\n                } else {\n                    return stringValue.String;\n                }\n            });\n\n        default:\n            if (collectionDefinition.length === 0) {\n                return [];\n            }\n            throw new Error('Unsupported case');\n    }\n}\n\nfunction isV4NavigationProperty(\n    navProp: RawV2NavigationProperty | RawV4NavigationProperty\n): navProp is RawV4NavigationProperty {\n    return !!(navProp as BaseNavigationProperty).targetTypeName;\n}\n\nfunction convertAnnotation(converter: Converter, target: any, rawAnnotation: RawAnnotation): Annotation {\n    let annotation: any;\n    if (rawAnnotation.record) {\n        annotation = parseRecord(\n            converter,\n            rawAnnotation.term,\n            target,\n            '',\n            (rawAnnotation as any).__source,\n            rawAnnotation.record,\n            (rawAnnotation as any).fullyQualifiedName\n        );\n    } else if (rawAnnotation.collection === undefined) {\n        annotation = parseValue(\n            converter,\n            target,\n            rawAnnotation.term,\n            '',\n            (rawAnnotation as any).__source,\n            rawAnnotation.value ?? { type: 'Bool', Bool: true },\n            (rawAnnotation as any).fullyQualifiedName\n        );\n    } else if (rawAnnotation.collection) {\n        annotation = parseCollection(\n            converter,\n            target,\n            rawAnnotation.term,\n            '',\n            (rawAnnotation as any).__source,\n            rawAnnotation.collection,\n            (rawAnnotation as any).fullyQualifiedName\n        );\n    } else {\n        throw new Error('Unsupported case');\n    }\n\n    switch (typeof annotation) {\n        case 'string':\n            // eslint-disable-next-line no-new-wrappers\n            annotation = new String(annotation);\n            break;\n        case 'boolean':\n            // eslint-disable-next-line no-new-wrappers\n            annotation = new Boolean(annotation);\n            break;\n        case 'number':\n            annotation = new Number(annotation);\n            break;\n        default:\n            // do nothing\n            break;\n    }\n\n    annotation.fullyQualifiedName = (rawAnnotation as any).fullyQualifiedName;\n    annotation[ANNOTATION_TARGET] = target;\n\n    const [vocAlias, vocTerm] = converter.splitTerm(rawAnnotation.term);\n\n    annotation.term = converter.unalias(`${vocAlias}.${vocTerm}`, VocabularyReferences);\n    annotation.qualifier = rawAnnotation.qualifier;\n    annotation.__source = (rawAnnotation as any).__source;\n\n    try {\n        lazy(annotation, 'annotations', resolveAnnotationsOnAnnotation(converter, rawAnnotation, annotation));\n    } catch (e) {\n        // not an error: parseRecord() already adds annotations, but the other parseXXX functions don't, so this can happen\n    }\n\n    return annotation as Annotation;\n}\n\nclass Converter {\n    private annotationsByTarget: Record<FullyQualifiedName, Annotation[]>;\n\n    /**\n     * Get preprocessed annotations on the specified target.\n     *\n     * @param target    The annotation target\n     * @returns An array of annotations\n     */\n    getAnnotations(target: FullyQualifiedName): Annotation[] {\n        if (this.annotationsByTarget === undefined) {\n            const annotationSources = Object.keys(this.rawSchema.annotations).map((source) => ({\n                name: source,\n                annotationList: this.rawSchema.annotations[source]\n            }));\n\n            this.annotationsByTarget = mergeAnnotations(this.rawMetadata.references, ...annotationSources);\n        }\n\n        return this.annotationsByTarget[target] ?? [];\n    }\n\n    getConvertedEntityContainer() {\n        return this.getConvertedElement(\n            this.rawMetadata.schema.entityContainer.fullyQualifiedName,\n            this.rawMetadata.schema.entityContainer,\n            convertEntityContainer\n        );\n    }\n\n    getConvertedEntitySet(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.entitySets.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    getConvertedSingleton(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.singletons.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    getConvertedEntityType(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.entityTypes.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    getConvertedComplexType(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.complexTypes.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    getConvertedTypeDefinition(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.typeDefinitions.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    getConvertedActionImport(fullyQualifiedName: FullyQualifiedName) {\n        let actionImport = this.convertedOutput.actionImports.by_fullyQualifiedName(fullyQualifiedName);\n        if (!actionImport) {\n            actionImport = this.convertedOutput.actionImports.by_name(fullyQualifiedName);\n        }\n        return actionImport;\n    }\n\n    getConvertedAction(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.actions.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    convert<Converted, Raw extends RawType<Converted>>(\n        rawValue: Raw,\n        map: (converter: Converter, raw: Raw) => Converted\n    ): () => Converted;\n    convert<Converted, Raw extends RawType<Converted>, IndexProperty extends Extract<keyof Converted, string>>(\n        rawValue: Raw[],\n        map: (converter: Converter, raw: Raw) => Converted\n    ): () => ArrayWithIndex<Converted, IndexProperty>;\n    convert<Converted, Raw extends RawType<Converted>, IndexProperty extends Extract<keyof Converted, string>>(\n        rawValue: Raw | Raw[],\n        map: (converter: Converter, raw: Raw) => Converted\n    ): (() => Converted) | (() => ArrayWithIndex<Converted, IndexProperty>) {\n        if (Array.isArray(rawValue)) {\n            return () => {\n                const converted = rawValue.reduce((convertedElements, rawElement) => {\n                    const convertedElement = this.getConvertedElement(\n                        (rawElement as any).fullyQualifiedName,\n                        rawElement,\n                        map\n                    );\n                    if (convertedElement) {\n                        convertedElements.push(convertedElement);\n                    }\n                    return convertedElements;\n                }, [] as Converted[]);\n                addGetByValue(converted, 'name' as any);\n                addGetByValue(converted, 'fullyQualifiedName' as any);\n                return converted as ArrayWithIndex<Converted, IndexProperty>;\n            };\n        } else {\n            return () => this.getConvertedElement(rawValue.fullyQualifiedName, rawValue, map)!;\n        }\n    }\n\n    private rawMetadata: RawMetadata;\n    private convertedElements: Map<FullyQualifiedName, any> = new Map();\n    private convertedOutput: ConvertedMetadata;\n\n    rawSchema: RawSchema;\n\n    constructor(rawMetadata: RawMetadata, convertedOutput: ConvertedMetadata) {\n        this.rawMetadata = rawMetadata;\n        this.rawSchema = rawMetadata.schema;\n        this.convertedOutput = convertedOutput;\n    }\n\n    getConvertedElement<ConvertedType, RawType extends RemoveAnnotationAndType<ConvertedType>>(\n        fullyQualifiedName: FullyQualifiedName,\n        rawElement: RawType | undefined | ((fullyQualifiedName: FullyQualifiedName) => RawType | undefined),\n        map: (converter: Converter, raw: RawType) => ConvertedType\n    ): ConvertedType | undefined {\n        let converted: ConvertedType | undefined = this.convertedElements.get(fullyQualifiedName);\n        if (converted === undefined) {\n            const rawMetadata =\n                typeof rawElement === 'function' ? rawElement.apply(undefined, [fullyQualifiedName]) : rawElement;\n            if (rawMetadata !== undefined) {\n                converted = map.apply(undefined, [this, rawMetadata]);\n                this.convertedElements.set(fullyQualifiedName, converted);\n            }\n        }\n        return converted;\n    }\n\n    logError(message: string) {\n        this.convertedOutput.diagnostics.push({ message });\n    }\n\n    /**\n     * Split the alias from the term value.\n     *\n     * @param term the value of the term\n     * @returns the term alias and the actual term value\n     */\n    splitTerm(term: string) {\n        const aliased = alias(VocabularyReferences, term);\n        return splitAtLast(aliased, '.');\n    }\n\n    unalias(value: string | undefined, references = this.rawMetadata.references) {\n        return unalias(references, value, this.rawSchema.namespace) ?? '';\n    }\n}\n\ntype RawType<T> = RemoveAnnotationAndType<T> & { fullyQualifiedName: FullyQualifiedName };\n\nfunction resolveEntityType(converter: Converter, fullyQualifiedName: FullyQualifiedName) {\n    return () => {\n        let entityType = converter.getConvertedEntityType(fullyQualifiedName);\n\n        if (!entityType) {\n            converter.logError(`EntityType '${fullyQualifiedName}' not found`);\n            entityType = {} as EntityType;\n        }\n        return entityType;\n    };\n}\n\nfunction resolveNavigationPropertyBindings(\n    converter: Converter,\n    rawNavigationPropertyBindings: RawNavigationPropertyBinding\n) {\n    return () =>\n        Object.keys(rawNavigationPropertyBindings).reduce((navigationPropertyBindings, bindingPath) => {\n            const rawBindingTarget = rawNavigationPropertyBindings[bindingPath];\n\n            lazy(\n                navigationPropertyBindings,\n                bindingPath,\n                () =>\n                    // the NavigationPropertyBinding will lead to either an EntitySet or a Singleton, it cannot be undefined\n                    (converter.getConvertedEntitySet(rawBindingTarget) ??\n                        converter.getConvertedSingleton(rawBindingTarget))!\n            );\n            return navigationPropertyBindings;\n        }, {} as EntitySet['navigationPropertyBinding'] | Singleton['navigationPropertyBinding']);\n}\n\nfunction resolveAnnotations(converter: Converter, rawAnnotationTarget: any) {\n    const nestedAnnotations = rawAnnotationTarget.annotations;\n\n    return () =>\n        createAnnotationsObject(\n            converter,\n            rawAnnotationTarget,\n            nestedAnnotations ?? converter.getAnnotations(rawAnnotationTarget.fullyQualifiedName)\n        );\n}\n\nfunction resolveAnnotationsOnAnnotation(\n    converter: Converter,\n    annotationRecord: AnnotationRecord | RawAnnotation,\n    annotationTerm: any\n) {\n    return () => {\n        const currentFQN = annotationTerm.fullyQualifiedName;\n\n        // be graceful when resolving annotations on annotations: Sometimes they are referenced directly, sometimes they\n        // are part of the global annotations list\n        let annotations;\n        if (annotationRecord.annotations && annotationRecord.annotations.length > 0) {\n            annotations = annotationRecord.annotations;\n        } else {\n            annotations = converter.getAnnotations(currentFQN);\n        }\n\n        annotations?.forEach((annotation: any) => {\n            annotation.target = currentFQN;\n            annotation.__source = annotationTerm.__source;\n            annotation[ANNOTATION_TARGET] = annotationTerm[ANNOTATION_TARGET];\n            annotation.fullyQualifiedName = `${currentFQN}@${annotation.term}`;\n        });\n\n        return createAnnotationsObject(converter, annotationTerm, annotations ?? []);\n    };\n}\n\nfunction createAnnotationsObject(converter: Converter, target: any, rawAnnotations: RawAnnotation[]) {\n    return rawAnnotations.reduce((vocabularyAliases, annotation) => {\n        const [vocAlias, vocTerm] = converter.splitTerm(annotation.term);\n        const vocTermWithQualifier = `${vocTerm}${annotation.qualifier ? '#' + annotation.qualifier : ''}`;\n\n        if (vocabularyAliases[vocAlias] === undefined) {\n            vocabularyAliases[vocAlias] = {};\n        }\n\n        if (!vocabularyAliases[vocAlias].hasOwnProperty(vocTermWithQualifier)) {\n            lazy(vocabularyAliases[vocAlias], vocTermWithQualifier, () =>\n                converter.getConvertedElement(\n                    (annotation as Annotation).fullyQualifiedName,\n                    annotation,\n                    (converter, rawAnnotation) => convertAnnotation(converter, target, rawAnnotation)\n                )\n            );\n        }\n        return vocabularyAliases;\n    }, {} as any);\n}\n\n/**\n * Converts an EntityContainer.\n *\n * @param converter     Converter\n * @param rawEntityContainer    Unconverted EntityContainer\n * @returns The converted EntityContainer\n */\nfunction convertEntityContainer(converter: Converter, rawEntityContainer: RawEntityContainer): EntityContainer {\n    const convertedEntityContainer = rawEntityContainer as EntityContainer;\n\n    lazy(convertedEntityContainer, 'annotations', resolveAnnotations(converter, rawEntityContainer));\n\n    lazy(convertedEntityContainer, 'entitySets', converter.convert(converter.rawSchema.entitySets, convertEntitySet));\n\n    lazy(convertedEntityContainer, 'singletons', converter.convert(converter.rawSchema.singletons, convertSingleton));\n\n    lazy(\n        convertedEntityContainer,\n        'actionImports',\n        converter.convert(converter.rawSchema.actionImports, convertActionImport)\n    );\n\n    return convertedEntityContainer;\n}\n\n/**\n * Converts a Singleton.\n *\n * @param converter   Converter\n * @param rawSingleton  Unconverted Singleton\n * @returns The converted Singleton\n */\nfunction convertSingleton(converter: Converter, rawSingleton: RawSingleton): Singleton {\n    const convertedSingleton = rawSingleton as unknown as Singleton;\n\n    lazy(convertedSingleton, 'entityType', resolveEntityType(converter, rawSingleton.entityTypeName));\n    lazy(convertedSingleton, 'annotations', resolveAnnotations(converter, convertedSingleton));\n\n    const _rawNavigationPropertyBindings = rawSingleton.navigationPropertyBinding;\n    lazy(\n        convertedSingleton,\n        'navigationPropertyBinding',\n        resolveNavigationPropertyBindings(converter, _rawNavigationPropertyBindings)\n    );\n\n    return convertedSingleton;\n}\n\n/**\n * Converts an EntitySet.\n *\n * @param converter   Converter\n * @param rawEntitySet  Unconverted EntitySet\n * @returns The converted EntitySet\n */\nfunction convertEntitySet(converter: Converter, rawEntitySet: RawEntitySet): EntitySet {\n    const convertedEntitySet = rawEntitySet as unknown as EntitySet;\n\n    lazy(convertedEntitySet, 'entityType', resolveEntityType(converter, rawEntitySet.entityTypeName));\n    lazy(convertedEntitySet, 'annotations', resolveAnnotations(converter, convertedEntitySet));\n\n    const _rawNavigationPropertyBindings = rawEntitySet.navigationPropertyBinding;\n    lazy(\n        convertedEntitySet,\n        'navigationPropertyBinding',\n        resolveNavigationPropertyBindings(converter, _rawNavigationPropertyBindings)\n    );\n\n    return convertedEntitySet;\n}\n\n/**\n * Converts an EntityType.\n *\n * @param converter   Converter\n * @param rawEntityType  Unconverted EntityType\n * @returns The converted EntityType\n */\nfunction convertEntityType(converter: Converter, rawEntityType: RawEntityType): EntityType {\n    const convertedEntityType = rawEntityType as EntityType;\n\n    rawEntityType.keys.forEach((keyProp: any) => {\n        keyProp.isKey = true;\n    });\n\n    lazy(convertedEntityType, 'annotations', resolveAnnotations(converter, rawEntityType));\n\n    lazy(convertedEntityType, 'keys', converter.convert(rawEntityType.keys, convertProperty));\n    lazy(convertedEntityType, 'entityProperties', converter.convert(rawEntityType.entityProperties, convertProperty));\n    lazy(\n        convertedEntityType,\n        'navigationProperties',\n        converter.convert(rawEntityType.navigationProperties as any[], convertNavigationProperty)\n    );\n\n    lazy(convertedEntityType, 'actions', () =>\n        converter.rawSchema.actions\n            .filter(\n                (rawAction) =>\n                    rawAction.isBound &&\n                    (rawAction.sourceType === rawEntityType.fullyQualifiedName ||\n                        rawAction.sourceType === `Collection(${rawEntityType.fullyQualifiedName})`)\n            )\n            .reduce((actions, rawAction) => {\n                const name = `${converter.rawSchema.namespace}.${rawAction.name}`;\n                actions[name] = converter.getConvertedAction(rawAction.fullyQualifiedName)!;\n                return actions;\n            }, {} as EntityType['actions'])\n    );\n\n    convertedEntityType.resolvePath = (relativePath: string, includeVisitedObjects?: boolean) => {\n        const resolved = resolveTarget(converter, rawEntityType, relativePath);\n        if (includeVisitedObjects) {\n            return { target: resolved.target, visitedObjects: resolved.objectPath, messages: resolved.messages };\n        } else {\n            return resolved.target;\n        }\n    };\n\n    return convertedEntityType;\n}\n\n/**\n * Converts a Property.\n *\n * @param converter   Converter\n * @param rawProperty  Unconverted Property\n * @returns The converted Property\n */\nfunction convertProperty(converter: Converter, rawProperty: RawProperty): Property {\n    const convertedProperty = rawProperty as Property;\n\n    lazy(convertedProperty, 'annotations', resolveAnnotations(converter, rawProperty));\n\n    lazy(convertedProperty, 'targetType', () => {\n        const type = rawProperty.type;\n        const typeName = type.startsWith('Collection') ? type.substring(11, type.length - 1) : type;\n\n        return converter.getConvertedComplexType(typeName) ?? converter.getConvertedTypeDefinition(typeName);\n    });\n\n    return convertedProperty;\n}\n\n/**\n * Converts a NavigationProperty.\n *\n * @param converter   Converter\n * @param rawNavigationProperty  Unconverted NavigationProperty\n * @returns The converted NavigationProperty\n */\nfunction convertNavigationProperty(\n    converter: Converter,\n    rawNavigationProperty: RawV2NavigationProperty | RawV4NavigationProperty\n): NavigationProperty {\n    const convertedNavigationProperty = rawNavigationProperty as NavigationProperty;\n\n    convertedNavigationProperty.referentialConstraint = convertedNavigationProperty.referentialConstraint ?? [];\n\n    if (!isV4NavigationProperty(rawNavigationProperty)) {\n        const associationEnd = converter.rawSchema.associations\n            .find((association) => association.fullyQualifiedName === rawNavigationProperty.relationship)\n            ?.associationEnd.find((end) => end.role === rawNavigationProperty.toRole);\n\n        convertedNavigationProperty.isCollection = associationEnd?.multiplicity === '*';\n        convertedNavigationProperty.targetTypeName = associationEnd?.type ?? '';\n    }\n\n    lazy(\n        convertedNavigationProperty,\n        'targetType',\n        resolveEntityType(converter, (rawNavigationProperty as NavigationProperty).targetTypeName)\n    );\n\n    lazy(convertedNavigationProperty, 'annotations', resolveAnnotations(converter, rawNavigationProperty));\n\n    return convertedNavigationProperty;\n}\n\n/**\n * Converts an ActionImport.\n *\n * @param converter   Converter\n * @param rawActionImport  Unconverted ActionImport\n * @returns The converted ActionImport\n */\nfunction convertActionImport(converter: Converter, rawActionImport: RawActionImport): ActionImport {\n    const convertedActionImport = rawActionImport as ActionImport;\n\n    lazy(convertedActionImport, 'annotations', resolveAnnotations(converter, rawActionImport));\n\n    lazy(convertedActionImport, 'action', () => {\n        const rawActions = converter.rawSchema.actions.filter(\n            (rawAction) => !rawAction.isBound && rawAction.fullyQualifiedName.startsWith(rawActionImport.actionName)\n        );\n\n        // this always resolves to a unique unbound action, but resolution of unbound functions can be ambiguous:\n        // unbound function FQNs have overloads depending on all of their parameters\n        if (rawActions.length > 1) {\n            converter.logError(`Ambiguous reference in action import: ${rawActionImport.fullyQualifiedName}`);\n        }\n\n        // return the first matching action or function\n        return converter.getConvertedAction(rawActions[0].fullyQualifiedName)!;\n    });\n\n    return convertedActionImport;\n}\n\n/**\n * Converts an Action.\n *\n * @param converter   Converter\n * @param rawAction  Unconverted Action\n * @returns The converted Action\n */\nfunction convertAction(converter: Converter, rawAction: RawAction): Action {\n    const convertedAction = rawAction as Action;\n\n    if (convertedAction.sourceType) {\n        lazy(convertedAction, 'sourceEntityType', resolveEntityType(converter, rawAction.sourceType));\n    }\n\n    if (convertedAction.returnType) {\n        lazy(convertedAction, 'returnEntityType', resolveEntityType(converter, rawAction.returnType));\n    }\n\n    lazy(convertedAction, 'parameters', converter.convert(rawAction.parameters, convertActionParameter));\n\n    lazy(convertedAction, 'annotations', () => {\n        /*\n            Annotation resolution rule for actions:\n\n            (1) annotation target: the specific unbound or bound overload, e.g.\n                    - for actions:   \"x.y.z.unboundAction()\" / \"x.y.z.boundAction(x.y.z.Entity)\"\n                    - for functions: \"x.y.z.unboundFunction(Edm.String)\" / \"x.y.z.unboundFunction(x.y.z.Entity,Edm.String)\"\n            (2) annotation target: unspecified overload, e.g.\n                - for actions:   \"x.y.z.unboundAction\" / \"x.y.z.boundAction\"\n                - for functions: \"x.y.z.unboundFunction\" / \"x.y.z.unboundFunction\"\n\n            When resolving (1) takes precedence over (2). That is, annotations on the specific overload overwrite\n            annotations on the unspecific overload, on term/qualifier level.\n        */\n\n        const unspecificOverloadTarget = substringBeforeFirst(rawAction.fullyQualifiedName, '(');\n        const specificOverloadTarget = rawAction.fullyQualifiedName;\n\n        const effectiveAnnotations = converter.getAnnotations(specificOverloadTarget);\n        const unspecificAnnotations = converter.getAnnotations(unspecificOverloadTarget);\n\n        for (const unspecificAnnotation of unspecificAnnotations) {\n            if (\n                !effectiveAnnotations.some(\n                    (annotation) =>\n                        annotation.term === unspecificAnnotation.term &&\n                        annotation.qualifier === unspecificAnnotation.qualifier\n                )\n            ) {\n                effectiveAnnotations.push(unspecificAnnotation);\n            }\n        }\n\n        return createAnnotationsObject(converter, rawAction, effectiveAnnotations);\n    });\n\n    return convertedAction;\n}\n\n/**\n * Converts an ActionParameter.\n *\n * @param converter   Converter\n * @param rawActionParameter  Unconverted ActionParameter\n * @returns The converted ActionParameter\n */\nfunction convertActionParameter(\n    converter: Converter,\n    rawActionParameter: RawAction['parameters'][number]\n): ActionParameter {\n    const convertedActionParameter = rawActionParameter as ActionParameter;\n\n    lazy(\n        convertedActionParameter,\n        'typeReference',\n        () =>\n            converter.getConvertedEntityType(rawActionParameter.type) ??\n            converter.getConvertedComplexType(rawActionParameter.type) ??\n            converter.getConvertedTypeDefinition(rawActionParameter.type)\n    );\n\n    lazy(convertedActionParameter, 'annotations', () => {\n        // annotations on action parameters are resolved following the rules for actions\n        const unspecificOverloadTarget =\n            rawActionParameter.fullyQualifiedName.substring(0, rawActionParameter.fullyQualifiedName.indexOf('(')) +\n            rawActionParameter.fullyQualifiedName.substring(rawActionParameter.fullyQualifiedName.indexOf(')') + 1);\n        const specificOverloadTarget = rawActionParameter.fullyQualifiedName;\n\n        const effectiveAnnotations = converter.getAnnotations(specificOverloadTarget);\n        const unspecificAnnotations = converter.getAnnotations(unspecificOverloadTarget);\n\n        for (const unspecificAnnotation of unspecificAnnotations) {\n            if (\n                !effectiveAnnotations.some(\n                    (annotation) =>\n                        annotation.term === unspecificAnnotation.term &&\n                        annotation.qualifier === unspecificAnnotation.qualifier\n                )\n            ) {\n                effectiveAnnotations.push(unspecificAnnotation);\n            }\n        }\n\n        return createAnnotationsObject(converter, rawActionParameter, effectiveAnnotations);\n    });\n\n    return convertedActionParameter;\n}\n\n/**\n * Converts a ComplexType.\n *\n * @param converter   Converter\n * @param rawComplexType  Unconverted ComplexType\n * @returns The converted ComplexType\n */\nfunction convertComplexType(converter: Converter, rawComplexType: RawComplexType): ComplexType {\n    const convertedComplexType = rawComplexType as ComplexType;\n\n    lazy(convertedComplexType, 'properties', converter.convert(rawComplexType.properties, convertProperty));\n    lazy(\n        convertedComplexType,\n        'navigationProperties',\n        converter.convert(rawComplexType.navigationProperties as any[], convertNavigationProperty)\n    );\n    lazy(convertedComplexType, 'annotations', resolveAnnotations(converter, rawComplexType));\n\n    return convertedComplexType;\n}\n\n/**\n * Converts a TypeDefinition.\n *\n * @param converter   Converter\n * @param rawTypeDefinition  Unconverted TypeDefinition\n * @returns The converted TypeDefinition\n */\nfunction convertTypeDefinition(converter: Converter, rawTypeDefinition: RawTypeDefinition): TypeDefinition {\n    const convertedTypeDefinition = rawTypeDefinition as TypeDefinition;\n\n    lazy(convertedTypeDefinition, 'annotations', resolveAnnotations(converter, rawTypeDefinition));\n\n    return convertedTypeDefinition;\n}\n\n/**\n * Convert a RawMetadata into an object representation to be used to easily navigate a metadata object and its annotation.\n *\n * @param rawMetadata\n * @returns the converted representation of the metadata.\n */\nexport function convert(rawMetadata: RawMetadata): ConvertedMetadata {\n    // Converter Output\n    const convertedOutput: ConvertedMetadata = {\n        version: rawMetadata.version,\n        namespace: rawMetadata.schema.namespace,\n        annotations: rawMetadata.schema.annotations,\n        references: VocabularyReferences,\n        diagnostics: []\n    } as any;\n\n    // fall back on the default references if the caller does not specify any\n    if (rawMetadata.references.length === 0) {\n        rawMetadata.references = VocabularyReferences;\n    }\n\n    // Converter\n    const converter = new Converter(rawMetadata, convertedOutput);\n\n    lazy(\n        convertedOutput,\n        'entityContainer',\n        converter.convert(converter.rawSchema.entityContainer, convertEntityContainer)\n    );\n    lazy(convertedOutput, 'entitySets', converter.convert(converter.rawSchema.entitySets, convertEntitySet));\n    lazy(convertedOutput, 'singletons', converter.convert(converter.rawSchema.singletons, convertSingleton));\n    lazy(convertedOutput, 'entityTypes', converter.convert(converter.rawSchema.entityTypes, convertEntityType));\n    lazy(convertedOutput, 'actions', converter.convert(converter.rawSchema.actions, convertAction));\n    lazy(convertedOutput, 'complexTypes', converter.convert(converter.rawSchema.complexTypes, convertComplexType));\n    lazy(convertedOutput, 'actionImports', converter.convert(converter.rawSchema.actionImports, convertActionImport));\n    lazy(\n        convertedOutput,\n        'typeDefinitions',\n        converter.convert(converter.rawSchema.typeDefinitions, convertTypeDefinition)\n    );\n\n    convertedOutput.resolvePath = function resolvePath<T>(path: string): ResolutionTarget<T> {\n        const targetResolution = resolveTarget<T>(converter, undefined, path);\n        if (targetResolution.target) {\n            appendObjectPath(targetResolution.objectPath, targetResolution.target);\n        }\n        return targetResolution;\n    };\n\n    return convertedOutput;\n}\n","export * from './converter';\nexport * from './utils';\nexport * from './writeback';\n","import type {\n    Annotation,\n    AnnotationList,\n    ArrayWithIndex,\n    ComplexType,\n    Index,\n    Reference,\n    TypeDefinition\n} from '@sap-ux/vocabularies-types';\n\nexport { EnumIsFlag } from '@sap-ux/vocabularies-types/vocabularies/EnumIsFlag';\nexport { TermToTypes } from '@sap-ux/vocabularies-types/vocabularies/TermToTypes';\nexport { VocabularyReferences as defaultReferences } from '@sap-ux/vocabularies-types/vocabularies/VocabularyReferences';\n\nexport type ReferencesWithMap = Reference[] & {\n    referenceMap?: Record<string, Reference>;\n    reverseReferenceMap?: Record<string, Reference>;\n};\n\nfunction splitAt(string: string, index: number): [string, string] {\n    return index < 0 ? [string, ''] : [string.substring(0, index), string.substring(index + 1)];\n}\n\nfunction substringAt(string: string, index: number) {\n    return index < 0 ? string : string.substring(0, index);\n}\n\n/**\n * Splits a string at the first occurrence of a separator.\n *\n * @param string    The string to split\n * @param separator Separator, e.g. a single character.\n * @returns An array consisting of two elements: the part before the first occurrence of the separator and the part after it. If the string does not contain the separator, the second element is the empty string.\n */\nexport function splitAtFirst(string: string, separator: string): [string, string] {\n    return splitAt(string, string.indexOf(separator));\n}\n\n/**\n * Splits a string at the last occurrence of a separator.\n *\n * @param string    The string to split\n * @param separator Separator, e.g. a single character.\n * @returns An array consisting of two elements: the part before the last occurrence of the separator and the part after it. If the string does not contain the separator, the second element is the empty string.\n */\nexport function splitAtLast(string: string, separator: string): [string, string] {\n    return splitAt(string, string.lastIndexOf(separator));\n}\n\n/**\n * Returns the substring before the first occurrence of a separator.\n *\n * @param string    The string\n * @param separator Separator, e.g. a single character.\n * @returns The substring before the first occurrence of the separator, or the input string if it does not contain the separator.\n */\nexport function substringBeforeFirst(string: string, separator: string): string {\n    return substringAt(string, string.indexOf(separator));\n}\n\n/**\n * Returns the substring before the last occurrence of a separator.\n *\n * @param string    The string\n * @param separator Separator, e.g. a single character.\n * @returns The substring before the last occurrence of the separator, or the input string if it does not contain the separator.\n */\nexport function substringBeforeLast(string: string, separator: string): string {\n    return substringAt(string, string.lastIndexOf(separator));\n}\n\n/**\n * Transform an unaliased string representation annotation to the aliased version.\n *\n * @param references currentReferences for the project\n * @param unaliasedValue the unaliased value\n * @returns the aliased string representing the same\n */\nexport function alias(references: ReferencesWithMap, unaliasedValue: string): string {\n    if (!references.reverseReferenceMap) {\n        references.reverseReferenceMap = references.reduce((map: Record<string, Reference>, ref) => {\n            map[ref.namespace] = ref;\n            return map;\n        }, {});\n    }\n    if (!unaliasedValue) {\n        return unaliasedValue;\n    }\n    const [namespace, value] = splitAtLast(unaliasedValue, '.');\n    const reference = references.reverseReferenceMap[namespace];\n    if (reference) {\n        return `${reference.alias}.${value}`;\n    } else if (unaliasedValue.includes('@')) {\n        // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem\n        const [preAlias, postAlias] = splitAtFirst(unaliasedValue, '@');\n        return `${preAlias}@${alias(references, postAlias)}`;\n    } else {\n        return unaliasedValue;\n    }\n}\n\n/**\n * Transform an aliased string to its unaliased version given a set of references.\n *\n * @param references The references to use for unaliasing.\n * @param aliasedValue The aliased value\n * @param namespace The fallback namespace\n * @returns The equal unaliased string.\n */\nexport function unalias(\n    references: ReferencesWithMap,\n    aliasedValue: string | undefined,\n    namespace?: string\n): string | undefined {\n    const _unalias = (value: string) => {\n        if (!references.referenceMap) {\n            references.referenceMap = Object.fromEntries(references.map((ref) => [ref.alias, ref]));\n        }\n\n        // Aliases are of type 'SimpleIdentifier' and must not contain dots\n        const [maybeAlias, rest] = splitAtFirst(value, '.');\n\n        if (!rest || rest.includes('.')) {\n            // either there is no dot in the value or there is more than one --> nothing to do\n            return value;\n        }\n\n        const isAnnotation = maybeAlias.startsWith('@');\n        const valueToUnalias = isAnnotation ? maybeAlias.substring(1) : maybeAlias;\n        const knownReference = references.referenceMap[valueToUnalias];\n        if (knownReference) {\n            return isAnnotation ? `@${knownReference.namespace}.${rest}` : `${knownReference.namespace}.${rest}`;\n        }\n\n        // The alias could not be resolved using the references. Assume it is the \"global\" alias (= namespace)\n        return namespace && !isAnnotation ? `${namespace}.${rest}` : value;\n    };\n\n    return aliasedValue\n        ?.split('/')\n        .reduce((segments, segment) => {\n            // the segment could be an action, like \"doSomething(foo.bar)\"\n            const [first, rest] = splitAtFirst(segment, '(');\n            const subSegment = [_unalias(first)];\n\n            if (rest) {\n                const parameter = rest.slice(0, -1); // remove trailing \")\"\n                subSegment.push(`(${_unalias(parameter)})`);\n            }\n            segments.push(subSegment.join(''));\n\n            return segments;\n        }, [] as string[])\n        ?.join('/');\n}\n\n/**\n * Differentiate between a ComplexType and a TypeDefinition.\n *\n * @param complexTypeDefinition\n * @returns true if the value is a complex type\n */\nexport function isComplexTypeDefinition(\n    complexTypeDefinition?: ComplexType | TypeDefinition\n): complexTypeDefinition is ComplexType {\n    return (\n        !!complexTypeDefinition && complexTypeDefinition._type === 'ComplexType' && !!complexTypeDefinition.properties\n    );\n}\n\nexport function Decimal(value: number) {\n    return {\n        isDecimal() {\n            return true;\n        },\n        valueOf() {\n            return value;\n        },\n        toString() {\n            return value.toString();\n        }\n    };\n}\n\n/**\n * Defines a lazy property.\n *\n * The property is initialized by calling the init function on the first read access, or by directly assigning a value.\n *\n * @param object    The host object\n * @param property  The lazy property to add\n * @param init      The function that initializes the property's value\n */\nexport function lazy<Type, Key extends keyof Type>(object: Type, property: Key, init: () => Type[Key]) {\n    const initial = Symbol('initial');\n    let _value: Type[Key] | typeof initial = initial;\n\n    Object.defineProperty(object, property, {\n        enumerable: true,\n\n        get() {\n            if (_value === initial) {\n                _value = init();\n            }\n            return _value;\n        },\n\n        set(value: Type[Key]) {\n            _value = value;\n        }\n    });\n}\n\n/**\n * Creates a function that allows to find an array element by property value.\n *\n * @param array     The array\n * @param property  Elements in the array are searched by this property\n * @returns A function that can be used to find an element of the array by property value.\n */\nexport function createIndexedFind<T>(array: Array<T>, property: keyof T) {\n    const index: Map<T[keyof T], T | undefined> = new Map();\n\n    return function find(value: T[keyof T]) {\n        const element = index.get(value);\n\n        if (element?.[property] === value) {\n            return element;\n        }\n\n        return array.find((element) => {\n            if (!element?.hasOwnProperty(property)) {\n                return false;\n            }\n\n            const propertyValue = element[property];\n            index.set(propertyValue, element);\n            return propertyValue === value;\n        });\n    };\n}\n\n/**\n * Adds a 'get by value' function to an array.\n *\n * If this function is called with addIndex(myArray, 'name'), a new function 'by_name(value)' will be added that allows to\n * find a member of the array by the value of its 'name' property.\n *\n * @param array      The array\n * @param property   The property that will be used by the 'by_{property}()' function\n * @returns The array with the added function\n */\nexport function addGetByValue<T, P extends Extract<keyof T, string>>(array: Array<T>, property: P) {\n    const indexName: keyof Index<T, P> = `by_${property}`;\n\n    if (!array.hasOwnProperty(indexName)) {\n        Object.defineProperty(array, indexName, { writable: false, value: createIndexedFind(array, property) });\n    } else {\n        throw new Error(`Property '${indexName}' already exists`);\n    }\n    return array as ArrayWithIndex<T, P>;\n}\n\n/**\n * Merge annotations from different sources together by overwriting at the term level.\n *\n * @param references        References, used to resolve aliased annotation targets and aliased annotation terms.\n * @param annotationSources Annotation sources\n * @returns the resulting merged annotations\n */\nexport function mergeAnnotations(\n    references: Reference[],\n    ...annotationSources: { name: string; annotationList: AnnotationList[] }[]\n): Record<string, Annotation[]> {\n    return annotationSources.reduceRight((result, { name, annotationList }) => {\n        for (const { target, annotations } of annotationList) {\n            const annotationTarget = unalias(references, target) ?? target;\n            if (!result[annotationTarget]) {\n                result[annotationTarget] = [];\n            }\n\n            const annotationsOnTarget = annotations\n                .map((rawAnnotation): Annotation => {\n                    rawAnnotation.term = unalias(references, rawAnnotation.term) ?? rawAnnotation.term;\n\n                    (rawAnnotation as any).fullyQualifiedName = rawAnnotation.qualifier\n                        ? `${annotationTarget}@${rawAnnotation.term}#${rawAnnotation.qualifier}`\n                        : `${annotationTarget}@${rawAnnotation.term}`;\n\n                    (rawAnnotation as any).__source = name;\n\n                    return rawAnnotation as Annotation;\n                })\n                .filter(\n                    (annotation) =>\n                        !result[annotationTarget].some(\n                            (existingAnnotation) =>\n                                existingAnnotation.term === annotation.term &&\n                                existingAnnotation.qualifier === annotation.qualifier\n                        )\n                );\n\n            result[annotationTarget].push(...annotationsOnTarget);\n        }\n\n        return result;\n    }, {} as Record<string, Annotation[]>);\n}\n","import type {\n    AnnotationPathExpression,\n    AnnotationRecord,\n    AnnotationTerm,\n    Expression,\n    NavigationPropertyPathExpression,\n    PathExpression,\n    PropertyPathExpression,\n    RawAnnotation,\n    Reference\n} from '@sap-ux/vocabularies-types';\nimport { unalias } from './utils';\n\n/**\n * Revert an object to its raw type equivalent.\n *\n * @param references the current reference\n * @param value the value to revert\n * @returns the raw value\n */\nfunction revertObjectToRawType(references: Reference[], value: any) {\n    let result: Expression | undefined;\n    if (Array.isArray(value)) {\n        result = {\n            type: 'Collection',\n            Collection: value.map((anno) => revertCollectionItemToRawType(references, anno)) as any[]\n        };\n    } else if (value.isDecimal?.()) {\n        result = {\n            type: 'Decimal',\n            Decimal: value.valueOf()\n        };\n    } else if (value.isString?.()) {\n        const valueMatches = value.valueOf().split('.');\n        if (valueMatches.length > 1 && references.find((ref) => ref.alias === valueMatches[0])) {\n            result = {\n                type: 'EnumMember',\n                EnumMember: value.valueOf()\n            };\n        } else {\n            result = {\n                type: 'String',\n                String: value.valueOf()\n            };\n        }\n    } else if (value.isInt?.()) {\n        result = {\n            type: 'Int',\n            Int: value.valueOf()\n        };\n    } else if (value.isFloat?.()) {\n        result = {\n            type: 'Float',\n            Float: value.valueOf()\n        };\n    } else if (value.isDate?.()) {\n        result = {\n            type: 'Date',\n            Date: value.valueOf()\n        };\n    } else if (value.isBoolean?.()) {\n        result = {\n            type: 'Bool',\n            Bool: value.valueOf()\n        };\n    } else if (value.type === 'Path') {\n        result = {\n            type: 'Path',\n            Path: value.path\n        };\n    } else if (value.type === 'AnnotationPath') {\n        result = {\n            type: 'AnnotationPath',\n            AnnotationPath: value.value\n        };\n    } else if (value.type === 'Apply') {\n        result = {\n            type: 'Apply',\n            Apply: value.Apply\n        };\n    } else if (value.type === 'Null') {\n        result = {\n            type: 'Null'\n        };\n    } else if (value.type === 'PropertyPath') {\n        result = {\n            type: 'PropertyPath',\n            PropertyPath: value.value\n        };\n    } else if (value.type === 'NavigationPropertyPath') {\n        result = {\n            type: 'NavigationPropertyPath',\n            NavigationPropertyPath: value.value\n        };\n    } else if (Object.prototype.hasOwnProperty.call(value, '$Type')) {\n        result = {\n            type: 'Record',\n            Record: revertCollectionItemToRawType(references, value) as AnnotationRecord\n        };\n    }\n    return result;\n}\n\n/**\n * Revert a value to its raw value depending on its type.\n *\n * @param references the current set of reference\n * @param value the value to revert\n * @returns the raw expression\n */\nfunction revertValueToRawType(references: Reference[], value: any): Expression | undefined {\n    let result: Expression | undefined;\n    const valueConstructor = value?.constructor.name;\n    switch (valueConstructor) {\n        case 'String':\n        case 'string':\n            const valueMatches = value.toString().split('.');\n            if (valueMatches.length > 1 && references.find((ref) => ref.alias === valueMatches[0])) {\n                result = {\n                    type: 'EnumMember',\n                    EnumMember: value.toString()\n                };\n            } else {\n                result = {\n                    type: 'String',\n                    String: value.toString()\n                };\n            }\n            break;\n        case 'Boolean':\n        case 'boolean':\n            result = {\n                type: 'Bool',\n                Bool: value.valueOf()\n            };\n            break;\n\n        case 'Number':\n        case 'number':\n            if (value.toString() === value.toFixed()) {\n                result = {\n                    type: 'Int',\n                    Int: value.valueOf()\n                };\n            } else {\n                result = {\n                    type: 'Decimal',\n                    Decimal: value.valueOf()\n                };\n            }\n            break;\n        case 'object':\n        default:\n            result = revertObjectToRawType(references, value);\n            break;\n    }\n    return result;\n}\n\nconst restrictedKeys = ['$Type', 'term', '__source', 'qualifier', 'ActionTarget', 'fullyQualifiedName', 'annotations'];\n\n/**\n * Revert the current embedded annotations to their raw type.\n *\n * @param references the current set of reference\n * @param currentAnnotations the collection item to evaluate\n * @param targetAnnotations the place where we need to add the annotation\n */\nfunction revertAnnotationsToRawType(\n    references: Reference[],\n    currentAnnotations: any,\n    targetAnnotations: RawAnnotation[]\n) {\n    Object.keys(currentAnnotations)\n        .filter((key) => key !== '_annotations')\n        .forEach((key) => {\n            Object.keys(currentAnnotations[key]).forEach((term) => {\n                const parsedAnnotation = revertTermToGenericType(references, currentAnnotations[key][term]);\n                if (!parsedAnnotation.term) {\n                    const unaliasedTerm = unalias(references, `${key}.${term}`);\n                    if (unaliasedTerm) {\n                        const qualifiedSplit = unaliasedTerm.split('#');\n                        parsedAnnotation.term = qualifiedSplit[0];\n                        if (qualifiedSplit.length > 1) {\n                            // Sub Annotation with a qualifier, not sure when that can happen in real scenarios\n                            parsedAnnotation.qualifier = qualifiedSplit[1];\n                        }\n                    }\n                }\n                targetAnnotations.push(parsedAnnotation);\n            });\n        });\n}\n\n/**\n * Revert the current collection item to the corresponding raw annotation.\n *\n * @param references the current set of reference\n * @param collectionItem the collection item to evaluate\n * @returns the raw type equivalent\n */\nfunction revertCollectionItemToRawType(\n    references: Reference[],\n    collectionItem: any\n):\n    | AnnotationRecord\n    | string\n    | PropertyPathExpression\n    | PathExpression\n    | NavigationPropertyPathExpression\n    | AnnotationPathExpression\n    | undefined {\n    if (typeof collectionItem === 'string') {\n        return collectionItem;\n    } else if (typeof collectionItem === 'object') {\n        if (collectionItem.hasOwnProperty('$Type')) {\n            // Annotation Record\n            const outItem: AnnotationRecord = {\n                type: collectionItem.$Type,\n                propertyValues: [] as any[]\n            };\n            // Could validate keys and type based on $Type\n            Object.keys(collectionItem).forEach((collectionKey) => {\n                if (restrictedKeys.indexOf(collectionKey) === -1) {\n                    const value = collectionItem[collectionKey];\n                    outItem.propertyValues.push({\n                        name: collectionKey,\n                        value: revertValueToRawType(references, value) as Expression\n                    });\n                } else if (collectionKey === 'annotations' && Object.keys(collectionItem[collectionKey]).length > 0) {\n                    outItem.annotations = [];\n                    revertAnnotationsToRawType(references, collectionItem[collectionKey], outItem.annotations);\n                }\n            });\n            return outItem;\n        } else if (collectionItem.type === 'PropertyPath') {\n            return {\n                type: 'PropertyPath',\n                PropertyPath: collectionItem.value\n            };\n        } else if (collectionItem.type === 'AnnotationPath') {\n            return {\n                type: 'AnnotationPath',\n                AnnotationPath: collectionItem.value\n            };\n        } else if (collectionItem.type === 'NavigationPropertyPath') {\n            return {\n                type: 'NavigationPropertyPath',\n                NavigationPropertyPath: collectionItem.value\n            };\n        }\n    }\n    return undefined;\n}\n\n/**\n * Revert an annotation term to it's generic or raw equivalent.\n *\n * @param references the reference of the current context\n * @param annotation the annotation term to revert\n * @returns the raw annotation\n */\nexport function revertTermToGenericType(references: Reference[], annotation: AnnotationTerm<any>): RawAnnotation {\n    const baseAnnotation: RawAnnotation = {\n        term: annotation.term,\n        qualifier: annotation.qualifier\n    };\n    if (Array.isArray(annotation)) {\n        // Collection\n        if (annotation.hasOwnProperty('annotations') && Object.keys((annotation as any).annotations).length > 0) {\n            // Annotation on a collection itself, not sure when that happens if at all\n            baseAnnotation.annotations = [];\n            revertAnnotationsToRawType(references, (annotation as any).annotations, baseAnnotation.annotations);\n        }\n        return {\n            ...baseAnnotation,\n            collection: annotation.map((anno) => revertCollectionItemToRawType(references, anno)) as any[]\n        };\n    } else if (annotation.hasOwnProperty('$Type')) {\n        return { ...baseAnnotation, record: revertCollectionItemToRawType(references, annotation) as any };\n    } else {\n        return { ...baseAnnotation, value: revertValueToRawType(references, annotation) };\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EnumIsFlag = void 0;\nexports.EnumIsFlag = {\n    \"Auth.KeyLocation\": false,\n    \"Core.RevisionKind\": false,\n    \"Core.DataModificationOperationKind\": false,\n    \"Core.Permission\": true,\n    \"Capabilities.ConformanceLevelType\": false,\n    \"Capabilities.IsolationLevel\": true,\n    \"Capabilities.NavigationType\": false,\n    \"Capabilities.SearchExpressions\": true,\n    \"Capabilities.HttpMethod\": true,\n    \"Aggregation.RollupType\": false,\n    \"Common.TextFormatType\": false,\n    \"Common.FilterExpressionType\": false,\n    \"Common.FieldControlType\": false,\n    \"Common.EffectType\": true,\n    \"Communication.KindType\": false,\n    \"Communication.ContactInformationType\": true,\n    \"Communication.PhoneType\": true,\n    \"Communication.GenderType\": false,\n    \"UI.VisualizationType\": false,\n    \"UI.CriticalityType\": false,\n    \"UI.ImprovementDirectionType\": false,\n    \"UI.TrendType\": false,\n    \"UI.ChartType\": false,\n    \"UI.ChartAxisScaleBehaviorType\": false,\n    \"UI.ChartAxisAutoScaleDataScopeType\": false,\n    \"UI.ChartDimensionRoleType\": false,\n    \"UI.ChartMeasureRoleType\": false,\n    \"UI.SelectionRangeSignType\": false,\n    \"UI.SelectionRangeOptionType\": false,\n    \"UI.TextArrangementType\": false,\n    \"UI.ImportanceType\": false,\n    \"UI.CriticalityRepresentationType\": false,\n    \"UI.OperationGroupingType\": false,\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TermToTypes = void 0;\nvar TermToTypes;\n(function (TermToTypes) {\n    TermToTypes[\"Org.OData.Authorization.V1.SecuritySchemes\"] = \"Org.OData.Authorization.V1.SecurityScheme\";\n    TermToTypes[\"Org.OData.Authorization.V1.Authorizations\"] = \"Org.OData.Authorization.V1.Authorization\";\n    TermToTypes[\"Org.OData.Core.V1.Revisions\"] = \"Org.OData.Core.V1.RevisionType\";\n    TermToTypes[\"Org.OData.Core.V1.Links\"] = \"Org.OData.Core.V1.Link\";\n    TermToTypes[\"Org.OData.Core.V1.Example\"] = \"Org.OData.Core.V1.ExampleValue\";\n    TermToTypes[\"Org.OData.Core.V1.Messages\"] = \"Org.OData.Core.V1.MessageType\";\n    TermToTypes[\"Org.OData.Core.V1.ValueException\"] = \"Org.OData.Core.V1.ValueExceptionType\";\n    TermToTypes[\"Org.OData.Core.V1.ResourceException\"] = \"Org.OData.Core.V1.ResourceExceptionType\";\n    TermToTypes[\"Org.OData.Core.V1.DataModificationException\"] = \"Org.OData.Core.V1.DataModificationExceptionType\";\n    TermToTypes[\"Org.OData.Core.V1.IsLanguageDependent\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.AppliesViaContainer\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.DereferenceableIDs\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.ConventionalIDs\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.Permissions\"] = \"Org.OData.Core.V1.Permission\";\n    TermToTypes[\"Org.OData.Core.V1.DefaultNamespace\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.Immutable\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.Computed\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.ComputedDefaultValue\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.IsURL\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.IsMediaType\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.ContentDisposition\"] = \"Org.OData.Core.V1.ContentDispositionType\";\n    TermToTypes[\"Org.OData.Core.V1.OptimisticConcurrency\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"Org.OData.Core.V1.AdditionalProperties\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.AutoExpand\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.AutoExpandReferences\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.MayImplement\"] = \"Org.OData.Core.V1.QualifiedTypeName\";\n    TermToTypes[\"Org.OData.Core.V1.Ordered\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.PositionalInsert\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.AlternateKeys\"] = \"Org.OData.Core.V1.AlternateKey\";\n    TermToTypes[\"Org.OData.Core.V1.OptionalParameter\"] = \"Org.OData.Core.V1.OptionalParameterType\";\n    TermToTypes[\"Org.OData.Core.V1.OperationAvailable\"] = \"Edm.Boolean\";\n    TermToTypes[\"Org.OData.Core.V1.RequiresExplicitBinding\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.ExplicitOperationBindings\"] = \"Org.OData.Core.V1.QualifiedBoundOperationName\";\n    TermToTypes[\"Org.OData.Core.V1.SymbolicName\"] = \"Org.OData.Core.V1.SimpleIdentifier\";\n    TermToTypes[\"Org.OData.Core.V1.GeometryFeature\"] = \"Org.OData.Core.V1.GeometryFeatureType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ConformanceLevel\"] = \"Org.OData.Capabilities.V1.ConformanceLevelType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.AsynchronousRequestsSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.BatchContinueOnErrorSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.IsolationSupported\"] = \"Org.OData.Capabilities.V1.IsolationLevel\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CrossJoinSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CallbackSupported\"] = \"Org.OData.Capabilities.V1.CallbackType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ChangeTracking\"] = \"Org.OData.Capabilities.V1.ChangeTrackingType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CountRestrictions\"] = \"Org.OData.Capabilities.V1.CountRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.NavigationRestrictions\"] = \"Org.OData.Capabilities.V1.NavigationRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.IndexableByKey\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.TopSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.SkipSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ComputeSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.SelectSupport\"] = \"Org.OData.Capabilities.V1.SelectSupportType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.BatchSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.BatchSupport\"] = \"Org.OData.Capabilities.V1.BatchSupportType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.FilterRestrictions\"] = \"Org.OData.Capabilities.V1.FilterRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.SortRestrictions\"] = \"Org.OData.Capabilities.V1.SortRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ExpandRestrictions\"] = \"Org.OData.Capabilities.V1.ExpandRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.SearchRestrictions\"] = \"Org.OData.Capabilities.V1.SearchRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.KeyAsSegmentSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.QuerySegmentSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.InsertRestrictions\"] = \"Org.OData.Capabilities.V1.InsertRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.DeepInsertSupport\"] = \"Org.OData.Capabilities.V1.DeepInsertSupportType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.UpdateRestrictions\"] = \"Org.OData.Capabilities.V1.UpdateRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.DeepUpdateSupport\"] = \"Org.OData.Capabilities.V1.DeepUpdateSupportType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.DeleteRestrictions\"] = \"Org.OData.Capabilities.V1.DeleteRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CollectionPropertyRestrictions\"] = \"Org.OData.Capabilities.V1.CollectionPropertyRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.OperationRestrictions\"] = \"Org.OData.Capabilities.V1.OperationRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.AnnotationValuesInQuerySupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ModificationQueryOptions\"] = \"Org.OData.Capabilities.V1.ModificationQueryOptionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ReadRestrictions\"] = \"Org.OData.Capabilities.V1.ReadRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CustomHeaders\"] = \"Org.OData.Capabilities.V1.CustomParameter\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CustomQueryOptions\"] = \"Org.OData.Capabilities.V1.CustomParameter\";\n    TermToTypes[\"Org.OData.Capabilities.V1.MediaLocationUpdateSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Aggregation.V1.ApplySupported\"] = \"Org.OData.Aggregation.V1.ApplySupportedType\";\n    TermToTypes[\"Org.OData.Aggregation.V1.ApplySupportedDefaults\"] = \"Org.OData.Aggregation.V1.ApplySupportedBase\";\n    TermToTypes[\"Org.OData.Aggregation.V1.Groupable\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Aggregation.V1.Aggregatable\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Aggregation.V1.ContextDefiningProperties\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"Org.OData.Aggregation.V1.LeveledHierarchy\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"Org.OData.Aggregation.V1.RecursiveHierarchy\"] = \"Org.OData.Aggregation.V1.RecursiveHierarchyType\";\n    TermToTypes[\"Org.OData.Aggregation.V1.AvailableOnAggregates\"] = \"Org.OData.Aggregation.V1.AvailableOnAggregatesType\";\n    TermToTypes[\"Org.OData.Validation.V1.Minimum\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"Org.OData.Validation.V1.Maximum\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"Org.OData.Validation.V1.Exclusive\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Validation.V1.AllowedValues\"] = \"Org.OData.Validation.V1.AllowedValue\";\n    TermToTypes[\"Org.OData.Validation.V1.MultipleOf\"] = \"Edm.Decimal\";\n    TermToTypes[\"Org.OData.Validation.V1.Constraint\"] = \"Org.OData.Validation.V1.ConstraintType\";\n    TermToTypes[\"Org.OData.Validation.V1.ItemsOf\"] = \"Org.OData.Validation.V1.ItemsOfType\";\n    TermToTypes[\"Org.OData.Validation.V1.OpenPropertyTypeConstraint\"] = \"Org.OData.Validation.V1.SingleOrCollectionType\";\n    TermToTypes[\"Org.OData.Validation.V1.DerivedTypeConstraint\"] = \"Org.OData.Validation.V1.SingleOrCollectionType\";\n    TermToTypes[\"Org.OData.Validation.V1.AllowedTerms\"] = \"Org.OData.Core.V1.QualifiedTermName\";\n    TermToTypes[\"Org.OData.Validation.V1.ApplicableTerms\"] = \"Org.OData.Core.V1.QualifiedTermName\";\n    TermToTypes[\"Org.OData.Validation.V1.MaxItems\"] = \"Edm.Int64\";\n    TermToTypes[\"Org.OData.Validation.V1.MinItems\"] = \"Edm.Int64\";\n    TermToTypes[\"Org.OData.Measures.V1.Scale\"] = \"Edm.Byte\";\n    TermToTypes[\"Org.OData.Measures.V1.DurationGranularity\"] = \"Org.OData.Measures.V1.DurationGranularityType\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.Dimension\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.Measure\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.AccumulativeMeasure\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.RolledUpPropertyCount\"] = \"Edm.Int16\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.PlanningAction\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.AggregatedProperties\"] = \"com.sap.vocabularies.Analytics.v1.AggregatedPropertyType\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.AggregatedProperty\"] = \"com.sap.vocabularies.Analytics.v1.AggregatedPropertyType\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.AnalyticalContext\"] = \"com.sap.vocabularies.Analytics.v1.AnalyticalContextType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ServiceVersion\"] = \"Edm.Int32\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ServiceSchemaVersion\"] = \"Edm.Int32\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.TextFor\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsLanguageIdentifier\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.TextFormat\"] = \"com.sap.vocabularies.Common.v1.TextFormatType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsTimezone\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsDigitSequence\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsUpperCase\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCurrency\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsUnit\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.UnitSpecificScale\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.UnitSpecificPrecision\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SecondaryKey\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.MinOccurs\"] = \"Edm.Int64\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.MaxOccurs\"] = \"Edm.Int64\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.AssociationEntity\"] = \"Edm.NavigationPropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.DerivedNavigation\"] = \"Edm.NavigationPropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Masked\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.RevealOnDemand\"] = \"Edm.Boolean\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SemanticObjectMapping\"] = \"com.sap.vocabularies.Common.v1.SemanticObjectMappingType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsInstanceAnnotation\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.FilterExpressionRestrictions\"] = \"com.sap.vocabularies.Common.v1.FilterExpressionRestrictionType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.FieldControl\"] = \"com.sap.vocabularies.Common.v1.FieldControlType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Application\"] = \"com.sap.vocabularies.Common.v1.ApplicationType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Timestamp\"] = \"Edm.DateTimeOffset\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ErrorResolution\"] = \"com.sap.vocabularies.Common.v1.ErrorResolutionType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Messages\"] = \"Edm.ComplexType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.numericSeverity\"] = \"com.sap.vocabularies.Common.v1.NumericMessageSeverityType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.MaximumNumericMessageSeverity\"] = \"com.sap.vocabularies.Common.v1.NumericMessageSeverityType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsActionCritical\"] = \"Edm.Boolean\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Attributes\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.RelatedRecursiveHierarchy\"] = \"Edm.AnnotationPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Interval\"] = \"com.sap.vocabularies.Common.v1.IntervalType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ResultContext\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SAPObjectNodeType\"] = \"com.sap.vocabularies.Common.v1.SAPObjectNodeTypeType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Composition\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsNaturalPerson\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ValueList\"] = \"com.sap.vocabularies.Common.v1.ValueListType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ValueListRelevantQualifiers\"] = \"Org.OData.Core.V1.SimpleIdentifier\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ValueListWithFixedValues\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ValueListMapping\"] = \"com.sap.vocabularies.Common.v1.ValueListMappingType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarYear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarHalfyear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarQuarter\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarMonth\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarWeek\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsDayOfCalendarMonth\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsDayOfCalendarYear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarYearHalfyear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarYearQuarter\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarYearMonth\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarYearWeek\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarDate\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalYear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalPeriod\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalYearPeriod\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalQuarter\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalYearQuarter\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalWeek\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalYearWeek\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsDayOfFiscalYear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalYearVariant\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.MutuallyExclusiveTerm\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.DraftRoot\"] = \"com.sap.vocabularies.Common.v1.DraftRootType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.DraftNode\"] = \"com.sap.vocabularies.Common.v1.DraftNodeType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.DraftActivationVia\"] = \"Org.OData.Core.V1.SimpleIdentifier\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.EditableFieldFor\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SemanticKey\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SideEffects\"] = \"com.sap.vocabularies.Common.v1.SideEffectsType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.DefaultValuesFunction\"] = \"com.sap.vocabularies.Common.v1.QualifiedName\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.FilterDefaultValue\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.FilterDefaultValueHigh\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SortOrder\"] = \"com.sap.vocabularies.Common.v1.SortOrderType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.RecursiveHierarchy\"] = \"com.sap.vocabularies.Common.v1.RecursiveHierarchyType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.CreatedAt\"] = \"Edm.DateTimeOffset\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.CreatedBy\"] = \"com.sap.vocabularies.Common.v1.UserID\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ChangedAt\"] = \"Edm.DateTimeOffset\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ChangedBy\"] = \"com.sap.vocabularies.Common.v1.UserID\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ApplyMultiUnitBehaviorForSortingAndFiltering\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.PrimitivePropertyPath\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.CodeList.v1.CurrencyCodes\"] = \"com.sap.vocabularies.CodeList.v1.CodeListSource\";\n    TermToTypes[\"com.sap.vocabularies.CodeList.v1.UnitsOfMeasure\"] = \"com.sap.vocabularies.CodeList.v1.CodeListSource\";\n    TermToTypes[\"com.sap.vocabularies.CodeList.v1.StandardCode\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.CodeList.v1.ExternalCode\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.CodeList.v1.IsConfigurationDeprecationCode\"] = \"Edm.Boolean\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.Contact\"] = \"com.sap.vocabularies.Communication.v1.ContactType\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.Address\"] = \"com.sap.vocabularies.Communication.v1.AddressType\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.IsEmailAddress\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.IsPhoneNumber\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.Event\"] = \"com.sap.vocabularies.Communication.v1.EventData\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.Task\"] = \"com.sap.vocabularies.Communication.v1.TaskData\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.Message\"] = \"com.sap.vocabularies.Communication.v1.MessageData\";\n    TermToTypes[\"com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchy\"] = \"com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchyType\";\n    TermToTypes[\"com.sap.vocabularies.PersonalData.v1.EntitySemantics\"] = \"com.sap.vocabularies.PersonalData.v1.EntitySemanticsType\";\n    TermToTypes[\"com.sap.vocabularies.PersonalData.v1.FieldSemantics\"] = \"com.sap.vocabularies.PersonalData.v1.FieldSemanticsType\";\n    TermToTypes[\"com.sap.vocabularies.PersonalData.v1.IsPotentiallyPersonal\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.PersonalData.v1.IsPotentiallySensitive\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Session.v1.StickySessionSupported\"] = \"com.sap.vocabularies.Session.v1.StickySessionSupportedType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.HeaderInfo\"] = \"com.sap.vocabularies.UI.v1.HeaderInfoType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Identification\"] = \"com.sap.vocabularies.UI.v1.DataFieldAbstract\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Badge\"] = \"com.sap.vocabularies.UI.v1.BadgeType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.LineItem\"] = \"com.sap.vocabularies.UI.v1.DataFieldAbstract\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.StatusInfo\"] = \"com.sap.vocabularies.UI.v1.DataFieldAbstract\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.FieldGroup\"] = \"com.sap.vocabularies.UI.v1.FieldGroupType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.ConnectedFields\"] = \"com.sap.vocabularies.UI.v1.ConnectedFieldsType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.GeoLocations\"] = \"com.sap.vocabularies.UI.v1.GeoLocationType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.GeoLocation\"] = \"com.sap.vocabularies.UI.v1.GeoLocationType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Contacts\"] = \"Edm.AnnotationPath\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.MediaResource\"] = \"com.sap.vocabularies.UI.v1.MediaResourceType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.DataPoint\"] = \"com.sap.vocabularies.UI.v1.DataPointType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.KPI\"] = \"com.sap.vocabularies.UI.v1.KPIType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Chart\"] = \"com.sap.vocabularies.UI.v1.ChartDefinitionType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.ValueCriticality\"] = \"com.sap.vocabularies.UI.v1.ValueCriticalityType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.CriticalityLabels\"] = \"com.sap.vocabularies.UI.v1.CriticalityLabelType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.SelectionFields\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Facets\"] = \"com.sap.vocabularies.UI.v1.Facet\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.HeaderFacets\"] = \"com.sap.vocabularies.UI.v1.Facet\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.QuickViewFacets\"] = \"com.sap.vocabularies.UI.v1.Facet\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.QuickCreateFacets\"] = \"com.sap.vocabularies.UI.v1.Facet\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.FilterFacets\"] = \"com.sap.vocabularies.UI.v1.ReferenceFacet\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.SelectionPresentationVariant\"] = \"com.sap.vocabularies.UI.v1.SelectionPresentationVariantType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.PresentationVariant\"] = \"com.sap.vocabularies.UI.v1.PresentationVariantType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.SelectionVariant\"] = \"com.sap.vocabularies.UI.v1.SelectionVariantType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.ThingPerspective\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.IsSummary\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.PartOfPreview\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Map\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Gallery\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.IsImageURL\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.IsImage\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.MultiLineText\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.TextArrangement\"] = \"com.sap.vocabularies.UI.v1.TextArrangementType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Note\"] = \"com.sap.vocabularies.UI.v1.NoteType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Importance\"] = \"com.sap.vocabularies.UI.v1.ImportanceType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Hidden\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.IsCopyAction\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.CreateHidden\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.UpdateHidden\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.DeleteHidden\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.HiddenFilter\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.AdaptationHidden\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.DataFieldDefault\"] = \"com.sap.vocabularies.UI.v1.DataFieldAbstract\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Criticality\"] = \"com.sap.vocabularies.UI.v1.CriticalityType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.CriticalityCalculation\"] = \"com.sap.vocabularies.UI.v1.CriticalityCalculationType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Emphasized\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.OrderBy\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.ParameterDefaultValue\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.RecommendationState\"] = \"com.sap.vocabularies.UI.v1.RecommendationStateType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.RecommendationList\"] = \"com.sap.vocabularies.UI.v1.RecommendationListType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.ExcludeFromNavigationContext\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.DoNotCheckScaleOfMeasuredQuantity\"] = \"Edm.Boolean\";\n    TermToTypes[\"com.sap.vocabularies.HTML5.v1.CssDefaults\"] = \"com.sap.vocabularies.HTML5.v1.CssDefaultsType\";\n})(TermToTypes = exports.TermToTypes || (exports.TermToTypes = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VocabularyReferences = void 0;\n/**\n * The list of vocabularies with default aliases.\n */\nexports.VocabularyReferences = [\n    { alias: \"Auth\", namespace: \"Org.OData.Authorization.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml\" },\n    { alias: \"Core\", namespace: \"Org.OData.Core.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml\" },\n    { alias: \"Capabilities\", namespace: \"Org.OData.Capabilities.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml\" },\n    { alias: \"Aggregation\", namespace: \"Org.OData.Aggregation.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.xml\" },\n    { alias: \"Validation\", namespace: \"Org.OData.Validation.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Validation.V1.xml\" },\n    { alias: \"Measures\", namespace: \"Org.OData.Measures.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Measures.V1.xml\" },\n    { alias: \"Analytics\", namespace: \"com.sap.vocabularies.Analytics.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/Analytics.xml\" },\n    { alias: \"Common\", namespace: \"com.sap.vocabularies.Common.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/Common.xml\" },\n    { alias: \"CodeList\", namespace: \"com.sap.vocabularies.CodeList.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/CodeList.xml\" },\n    { alias: \"Communication\", namespace: \"com.sap.vocabularies.Communication.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/Communication.xml\" },\n    { alias: \"Hierarchy\", namespace: \"com.sap.vocabularies.Hierarchy.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/Hierarchy.xml\" },\n    { alias: \"PersonalData\", namespace: \"com.sap.vocabularies.PersonalData.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/PersonalData.xml\" },\n    { alias: \"Session\", namespace: \"com.sap.vocabularies.Session.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/Session.xml\" },\n    { alias: \"UI\", namespace: \"com.sap.vocabularies.UI.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/UI.xml\" },\n    { alias: \"HTML5\", namespace: \"com.sap.vocabularies.HTML5.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/HTML5.xml\" }\n];\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n",null],"mappings":"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"}