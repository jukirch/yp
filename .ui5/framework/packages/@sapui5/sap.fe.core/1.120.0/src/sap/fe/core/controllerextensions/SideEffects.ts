import Log from "sap/base/Log";
import type { FEView } from "sap/fe/core/BaseController";
import type {
	ControlSideEffectsType,
	ODataSideEffectsType,
	SideEffectsService,
	SideEffectsTarget,
	SideEffectsType
} from "sap/fe/core/services/SideEffectsServiceFactory";
import type Control from "sap/ui/core/Control";
import type { Control$ValidateFieldGroupEvent } from "sap/ui/core/Control";
import ControllerExtension from "sap/ui/core/mvc/ControllerExtension";
import type { Field$ChangeEvent } from "sap/ui/mdc/Field";
import type Context from "sap/ui/model/odata/v4/Context";
import CommonUtils from "../CommonUtils";
import type PageController from "../PageController";
import type { BaseManifestSettings } from "../converters/ManifestSettings";
import { defineUI5Class, finalExtension, methodOverride, privateExtension, publicExtension } from "../helpers/ClassSupport";

type BaseSideEffectPropertyType = {
	name: string;
	immediate?: boolean;
	sideEffects: SideEffectsType;
};

export type MassEditFieldSideEffectPropertyType = BaseSideEffectPropertyType;

export type FieldSideEffectPropertyType = BaseSideEffectPropertyType & {
	context: Context;
};

export type FieldSideEffectDictionary = Record<string, FieldSideEffectPropertyType>;

export type MassEditFieldSideEffectDictionary = Record<string, MassEditFieldSideEffectPropertyType>;

type FailedSideEffectDictionary = Record<string, SideEffectsType[]>;

export type FieldGroupSideEffectType = {
	promise: Promise<any>;
	sideEffectProperty: FieldSideEffectPropertyType;
};

const IMMEDIATE_REQUEST = "$$ImmediateRequest";
@defineUI5Class("sap.fe.core.controllerextensions.SideEffects")
class SideEffectsControllerExtension extends ControllerExtension {
	protected base!: PageController;

	private _view!: FEView;

	private _registeredFieldGroupMap!: Record<string, FieldGroupSideEffectType>;

	private _fieldGroupInvalidity!: Record<string, Record<string, boolean>>;

	private _sideEffectsService!: SideEffectsService;

	private _registeredFailedSideEffects!: FailedSideEffectDictionary;

	@methodOverride()
	onInit() {
		this._view = this.base.getView();
		this._sideEffectsService = CommonUtils.getAppComponent(this._view).getSideEffectsService();
		this._registeredFieldGroupMap = {};
		this._fieldGroupInvalidity = {};
		this._registeredFailedSideEffects = {};
	}

	/**
	 * Adds a SideEffects control.
	 *
	 * @param entityType Name of the entity where the SideEffects control will be registered
	 * @param controlSideEffects SideEffects to register. Ensure the sourceControlId matches the associated SAPUI5 control ID.
	 */
	@publicExtension()
	@finalExtension()
	addControlSideEffects(entityType: string, controlSideEffects: Omit<ControlSideEffectsType, "fullyQualifiedName">): void {
		this._sideEffectsService.addControlSideEffects(entityType, controlSideEffects);
	}

	/**
	 * Removes SideEffects created by a control.
	 *
	 * @param control SAPUI5 Control
	 */
	@publicExtension()
	@finalExtension()
	removeControlSideEffects(control: Control): void {
		const controlId = control.isA?.("sap.ui.base.ManagedObject") && control.getId();

		if (controlId) {
			this._sideEffectsService.removeControlSideEffects(controlId);
		}
	}

	/**
	 * Gets the appropriate context on which SideEffects can be requested.
	 * The correct one must have the binding parameter $$patchWithoutSideEffects.
	 *
	 * @param bindingContext Initial binding context
	 * @param sideEffectEntityType EntityType of the sideEffects
	 * @returns SAPUI5 Context or undefined
	 */
	@publicExtension()
	@finalExtension()
	getContextForSideEffects(bindingContext: any, sideEffectEntityType: string): Context | undefined {
		let contextForSideEffects = bindingContext,
			entityType = this._sideEffectsService.getEntityTypeFromContext(bindingContext);

		if (sideEffectEntityType !== entityType) {
			contextForSideEffects = bindingContext.getBinding().getContext();
			if (contextForSideEffects) {
				entityType = this._sideEffectsService.getEntityTypeFromContext(contextForSideEffects);
				if (sideEffectEntityType !== entityType) {
					contextForSideEffects = contextForSideEffects.getBinding().getContext();
					if (contextForSideEffects) {
						entityType = this._sideEffectsService.getEntityTypeFromContext(contextForSideEffects);
						if (sideEffectEntityType !== entityType) {
							return undefined;
						}
					}
				}
			}
		}

		return contextForSideEffects || undefined;
	}

	/**
	 * Gets the SideEffects map for a field
	 * These SideEffects are
	 * - listed into FieldGroupIds (coming from an OData Service)
	 * - generated by a control or controls and that configure this field as SourceProperties.
	 *
	 * @param field Field control
	 * @returns SideEffects map
	 */
	@publicExtension()
	@finalExtension()
	getFieldSideEffectsMap(field: Control): FieldSideEffectDictionary {
		let sideEffectsMap: FieldSideEffectDictionary = {};
		const fieldGroupIds = field.getFieldGroupIds(),
			viewEntitySetSetName = (this._view.getViewData() as BaseManifestSettings).entitySet,
			viewEntitySet = this._sideEffectsService.getConvertedMetaModel().entitySets.find((entitySet) => {
				return entitySet.name === viewEntitySetSetName;
			});

		// SideEffects coming from an OData Service
		sideEffectsMap = this.getSideEffectsMapForFieldGroups(
			fieldGroupIds,
			field.getBindingContext() as Context | null | undefined
		) as FieldSideEffectDictionary;

		// SideEffects coming from control(s)
		if (viewEntitySetSetName && viewEntitySet) {
			const viewEntityType = viewEntitySet.entityType.fullyQualifiedName,
				fieldPath = this.getTargetProperty(field),
				context = this.getContextForSideEffects(field.getBindingContext(), viewEntityType);

			if (fieldPath && context) {
				const controlSideEffectsEntityType = this._sideEffectsService.getControlEntitySideEffects(viewEntityType);
				Object.keys(controlSideEffectsEntityType).forEach((sideEffectsName) => {
					const oControlSideEffects = controlSideEffectsEntityType[sideEffectsName];
					if (oControlSideEffects.sourceProperties.includes(fieldPath)) {
						const name = `${sideEffectsName}::${viewEntityType}`;
						sideEffectsMap[name] = {
							name: name,
							immediate: true,
							sideEffects: oControlSideEffects,
							context: context
						};
					}
				});
			}
		}
		return sideEffectsMap;
	}

	/**
	 * Gets the sideEffects map for fieldGroups.
	 *
	 * @param fieldGroupIds Field group ids
	 * @param fieldContext Field binding context
	 * @returns SideEffects map
	 */

	@publicExtension()
	@finalExtension()
	getSideEffectsMapForFieldGroups(
		fieldGroupIds: string[],
		fieldContext?: Context | null
	): MassEditFieldSideEffectDictionary | FieldSideEffectDictionary {
		const mSideEffectsMap: MassEditFieldSideEffectDictionary | FieldSideEffectDictionary = {};
		fieldGroupIds.forEach((fieldGroupId) => {
			const { name, immediate, sideEffects, sideEffectEntityType } = this._getSideEffectsPropertyForFieldGroup(fieldGroupId);
			const oContext = fieldContext ? (this.getContextForSideEffects(fieldContext, sideEffectEntityType) as Context) : undefined;
			if (sideEffects && (!fieldContext || (fieldContext && oContext))) {
				mSideEffectsMap[name] = {
					name,
					immediate,
					sideEffects
				};
				if (fieldContext) {
					(mSideEffectsMap[name] as FieldSideEffectPropertyType).context = oContext!;
				}
			}
		});
		return mSideEffectsMap;
	}

	/**
	 * Clear recorded validation status for all properties.
	 *
	 */
	@publicExtension()
	@finalExtension()
	clearFieldGroupsValidity(): void {
		this._fieldGroupInvalidity = {};
	}

	/**
	 * Clear recorded validation status for all properties.
	 *
	 * @param fieldGroupId Field group id
	 * @param context Context
	 * @returns SAPUI5 Context or undefined
	 */
	@publicExtension()
	@finalExtension()
	isFieldGroupValid(fieldGroupId: string, context: Context): boolean {
		const id = this._getFieldGroupIndex(fieldGroupId, context);
		return Object.keys(this._fieldGroupInvalidity[id] ?? {}).length === 0;
	}

	/**
	 * Gets the relative target property related to the Field.
	 *
	 * @param field Field control
	 * @returns Relative target property
	 */
	@publicExtension()
	@finalExtension()
	getTargetProperty(field: Control): string | undefined {
		const fieldPath = field.data("sourcePath") as string;
		const metaModel = this._view.getModel().getMetaModel();
		const viewBindingPath = this._view.getBindingContext()?.getPath();
		const viewMetaModelPath = viewBindingPath ? `${metaModel.getMetaPath(viewBindingPath)}/` : "";
		return fieldPath?.replace(viewMetaModelPath, "");
	}

	/**
	 * Caches deferred SideEffects that will be executed when the FieldGroup is unfocused.
	 *
	 * @param event SAPUI5 event that comes from a field change
	 * @param fieldValidity
	 * @param fieldGroupPreRequisite Promise to be fulfilled before executing deferred SideEffects
	 */
	@publicExtension()
	@finalExtension()
	prepareSideEffectsForField(event: Field$ChangeEvent, fieldValidity: boolean, fieldGroupPreRequisite?: Promise<unknown>): void {
		const field = event.getSource() as Control;
		this._saveFieldPropertiesStatus(field, fieldValidity);
		if (!fieldValidity) {
			return;
		}
		const sideEffectsMap = this.getFieldSideEffectsMap(field);

		// register field group SideEffects
		Object.keys(sideEffectsMap)
			.filter((sideEffectsName) => sideEffectsMap[sideEffectsName].immediate !== true)
			.forEach((sideEffectsName) => {
				const sideEffectsProperties = sideEffectsMap[sideEffectsName];
				this.registerFieldGroupSideEffects(sideEffectsProperties, fieldGroupPreRequisite);
			});
	}

	/**
	 * Manages the workflow for SideEffects with related changes to a field
	 * The following scenarios are managed:
	 *  - Register: caches deferred SideEffects that will be executed when the FieldGroup is unfocused
	 *  - Execute: triggers immediate SideEffects requests if the promise for the field event is fulfilled.
	 *
	 * @param event SAPUI5 event that comes from a field change
	 * @param fieldValidity
	 * @param fieldGroupPreRequisite Promise to be fulfilled before executing deferred SideEffects
	 * @returns  Promise on SideEffects request(s)
	 */
	@publicExtension()
	@finalExtension()
	async handleFieldChange(event: Field$ChangeEvent, fieldValidity: boolean, fieldGroupPreRequisite?: Promise<unknown>): Promise<void> {
		const field = event.getSource() as Control;
		this.prepareSideEffectsForField(event, fieldValidity, fieldGroupPreRequisite);
		return this._manageSideEffectsFromField(field);
	}

	/**
	 * Manages SideEffects with a related 'focus out' to a field group.
	 *
	 * @param event SAPUI5 Event
	 * @returns Promise returning true if the SideEffects have been successfully executed
	 */
	@publicExtension()
	@finalExtension()
	async handleFieldGroupChange(event: Control$ValidateFieldGroupEvent): Promise<void | void[]> {
		const field = event.getSource() as Control,
			fieldGroupIds: string[] = event.getParameter("fieldGroupIds") ?? [],
			fieldGroupsSideEffects = fieldGroupIds.reduce((results: FieldGroupSideEffectType[], fieldGroupId) => {
				return results.concat(this.getRegisteredSideEffectsForFieldGroup(fieldGroupId));
			}, []);

		return Promise.all(
			fieldGroupsSideEffects.map((fieldGroupSideEffects) => {
				return this._requestFieldGroupSideEffects(fieldGroupSideEffects);
			})
		).catch((error) => {
			const contextPath = field.getBindingContext()?.getPath();
			Log.debug(`Error while processing FieldGroup SideEffects on context ${contextPath}`, error);
		});
	}

	/**
	 * Request SideEffects on a specific context.
	 *
	 * @param sideEffects SideEffects to be executed
	 * @param context Context where SideEffects need to be executed
	 * @param groupId
	 * @param fnGetTargets The callback function which will give us the targets and actions if it was coming through some specific handling.
	 * @param ignoreTriggerActions If true, we do not trigger actions defined in the side effect
	 * @returns SideEffects request on SAPUI5 context
	 */
	@publicExtension()
	@finalExtension()
	async requestSideEffects(
		sideEffects: SideEffectsType,
		context: Context,
		groupId?: string,
		fnGetTargets?: Function,
		ignoreTriggerActions = false
	): Promise<unknown> {
		let targets: SideEffectsTarget[], triggerAction;
		if (fnGetTargets) {
			const targetsAndActionData = await fnGetTargets(sideEffects);
			targets = targetsAndActionData["aTargets"];
			triggerAction = targetsAndActionData["TriggerAction"];
		} else {
			targets = [...(sideEffects.targetEntities ?? []), ...(sideEffects.targetProperties ?? [])];
			triggerAction = (sideEffects as ODataSideEffectsType).triggerAction;
		}
		if (triggerAction && !ignoreTriggerActions) {
			this._sideEffectsService.executeAction(triggerAction, context, groupId);
		}

		if (targets.length) {
			return this._sideEffectsService.requestSideEffects(targets, context, groupId).catch((error: unknown) => {
				this.registerFailedSideEffects([sideEffects], context);
				throw error;
			});
		}
	}

	/**
	 * Request multiple SideEffects on a specific context.
	 *
	 * @param multiSideEffects SideEffects to be executed
	 * @param context Context where SideEffects need to be executed
	 * @param groupId The group id of the batch
	 * @returns SideEffects request on SAPUI5 context
	 */
	async requestMultipleSideEffects(multiSideEffects: SideEffectsType[], context: Context, groupId?: string): Promise<unknown> {
		let properties = new Set<string>();
		let navigationProperties = new Set<string>();
		const actions = multiSideEffects.reduce((actions, sideEffects) => {
			const sideEffectAction = (sideEffects as ODataSideEffectsType).triggerAction;
			if (sideEffectAction) {
				actions.push(sideEffectAction);
			}
			return actions;
		}, [] as string[]);

		for (const action of actions) {
			this._sideEffectsService.executeAction(action, context, groupId);
		}

		for (const sideEffects of multiSideEffects) {
			properties = (sideEffects.targetProperties ?? []).reduce((mySet, property) => mySet.add(property), properties);
			navigationProperties = (sideEffects.targetEntities ?? []).reduce(
				(mySet, navigationProperty) => mySet.add(navigationProperty.$NavigationPropertyPath),
				navigationProperties
			);
		}

		return this._sideEffectsService
			.requestSideEffects(
				[
					...Array.from(properties),
					...Array.from(navigationProperties).map((navigationProperty) => {
						return { $NavigationPropertyPath: navigationProperty };
					})
				],
				context,
				groupId
			)
			.catch((error: unknown) => {
				this.registerFailedSideEffects(multiSideEffects, context);
				throw error;
			});
	}

	/**
	 * Gets failed SideEffects.
	 *
	 * @returns Registered SideEffects requests that have failed
	 */
	@publicExtension()
	@finalExtension()
	public getRegisteredFailedRequests(): FailedSideEffectDictionary {
		return this._registeredFailedSideEffects;
	}

	/**
	 * Adds SideEffects to the queue of the failed SideEffects
	 * The SideEffects are retriggered on the next request on the same context.
	 *
	 * @param sideEffects SideEffects that need to be retriggered
	 * @param context Context where SideEffects have failed
	 */
	@privateExtension()
	@finalExtension()
	registerFailedSideEffects(multiSideEffects: SideEffectsType[], context: Context): void {
		const contextPath = context.getPath();
		this._registeredFailedSideEffects[contextPath] = this._registeredFailedSideEffects[contextPath] ?? [];
		for (const sideEffects of multiSideEffects) {
			const isNotAlreadyListed = this._registeredFailedSideEffects[contextPath].every(
				(mFailedSideEffects) => sideEffects.fullyQualifiedName !== mFailedSideEffects.fullyQualifiedName
			);
			if (isNotAlreadyListed) {
				this._registeredFailedSideEffects[contextPath].push(sideEffects);
			}
		}
	}

	/**
	 * Deletes SideEffects in the queue of the failed SideEffects for a context.
	 *
	 * @param contextPath Context path where SideEffects have failed
	 */
	@publicExtension()
	@finalExtension()
	unregisterFailedSideEffectsForAContext(contextPath: string) {
		delete this._registeredFailedSideEffects[contextPath];
	}

	/**
	 * Deletes SideEffects to the queue of the failed SideEffects.
	 *
	 * @param sideEffectsFullyQualifiedName SideEffects that need to be retriggered
	 * @param context Context where SideEffects have failed
	 */
	@publicExtension()
	@finalExtension()
	unregisterFailedSideEffects(sideEffectsFullyQualifiedName: string, context: Context): void {
		const contextPath = context.getPath();
		if (this._registeredFailedSideEffects[contextPath]?.length) {
			this._registeredFailedSideEffects[contextPath] = this._registeredFailedSideEffects[contextPath].filter(
				(sideEffects) => sideEffects.fullyQualifiedName !== sideEffectsFullyQualifiedName
			);
		}
	}

	/**
	 * Adds SideEffects to the queue of a FieldGroup
	 * The SideEffects are triggered when event related to the field group change is fired.
	 *
	 * @param sideEffectsProperties SideEffects properties
	 * @param fieldGroupPreRequisite Promise to fullfil before executing the SideEffects
	 */
	@privateExtension()
	@finalExtension()
	registerFieldGroupSideEffects(sideEffectsProperties: FieldSideEffectPropertyType, fieldGroupPreRequisite?: Promise<unknown>) {
		const id = this._getFieldGroupIndex(sideEffectsProperties.name, sideEffectsProperties.context);
		if (!this._registeredFieldGroupMap[id]) {
			this._registeredFieldGroupMap[id] = {
				promise: fieldGroupPreRequisite ?? Promise.resolve(),
				sideEffectProperty: sideEffectsProperties
			};
		}
	}

	/**
	 * Deletes SideEffects to the queue of a FieldGroup.
	 *
	 * @param sideEffectsProperties SideEffects properties
	 */
	@privateExtension()
	@finalExtension()
	unregisterFieldGroupSideEffects(sideEffectsProperties: FieldSideEffectPropertyType) {
		const { context, name } = sideEffectsProperties;
		const id = this._getFieldGroupIndex(name, context);
		delete this._registeredFieldGroupMap[id];
	}

	/**
	 * Gets the registered SideEffects into the queue for a field group id.
	 *
	 * @param fieldGroupId Field group id
	 * @returns Array of registered SideEffects and their promise
	 */
	@publicExtension()
	@finalExtension()
	getRegisteredSideEffectsForFieldGroup(fieldGroupId: string): FieldGroupSideEffectType[] {
		const sideEffects = [];
		for (const registryIndex of Object.keys(this._registeredFieldGroupMap)) {
			if (registryIndex.startsWith(`${fieldGroupId}_`)) {
				sideEffects.push(this._registeredFieldGroupMap[registryIndex]);
			}
		}
		return sideEffects;
	}

	/**
	 * Gets a status index.
	 *
	 * @param fieldGroupId The field group id
	 * @param context SAPUI5 Context
	 * @returns Index
	 */
	private _getFieldGroupIndex(fieldGroupId: string, context: Context): string {
		return `${fieldGroupId}_${context.getPath()}`;
	}

	/**
	 * Gets sideEffects properties from a field group id
	 * The properties are:
	 *  - name
	 *  - sideEffects definition
	 *  - sideEffects entity type
	 *  - immediate sideEffects.
	 *
	 * @param fieldGroupId
	 * @returns SideEffects properties
	 */
	private _getSideEffectsPropertyForFieldGroup(fieldGroupId: string) {
		/**
		 * string "$$ImmediateRequest" is added to the SideEffects name during templating to know
		 * if this SideEffects must be immediately executed requested (on field change) or must
		 * be deferred (on field group focus out)
		 *
		 */
		const immediate = fieldGroupId.includes(IMMEDIATE_REQUEST),
			name = fieldGroupId.replace(IMMEDIATE_REQUEST, ""),
			sideEffectParts = name.split("#"),
			sideEffectEntityType = sideEffectParts[0],
			sideEffectPath = `${sideEffectEntityType}@com.sap.vocabularies.Common.v1.SideEffects${
				sideEffectParts.length === 2 ? `#${sideEffectParts[1]}` : ""
			}`,
			sideEffects: ODataSideEffectsType | undefined =
				this._sideEffectsService.getODataEntitySideEffects(sideEffectEntityType)?.[sideEffectPath];
		return { name, immediate, sideEffects, sideEffectEntityType };
	}

	/**
	 * Manages the SideEffects for a field.
	 *
	 * @param field Field control
	 * @returns Promise related to the requested immediate sideEffects
	 */
	private async _manageSideEffectsFromField(field: Control): Promise<void> {
		const sideEffectsMap = this.getFieldSideEffectsMap(field);
		try {
			const sideEffectsToExecute: Record<string, { sideEffects: SideEffectsType[]; context: Context }> = {};
			const addSideEffects = (context: Context, sideEffects: SideEffectsType): void => {
				const contextPath = context.getPath();
				if (sideEffectsToExecute[contextPath]) {
					sideEffectsToExecute[contextPath].sideEffects.push(sideEffects);
				} else {
					sideEffectsToExecute[contextPath] = {
						context,
						sideEffects: [sideEffects]
					};
				}
			};

			//Get Immediate SideEffects
			for (const sideEffectsProperties of Object.values(sideEffectsMap).filter(
				(sideEffectsProperties) => sideEffectsProperties.immediate === true
			)) {
				// if this SideEffects is recorded as failed SideEffects, need to remove it.
				this.unregisterFailedSideEffects(sideEffectsProperties.sideEffects.fullyQualifiedName, sideEffectsProperties.context);
				addSideEffects(sideEffectsProperties.context, sideEffectsProperties.sideEffects);
			}

			//Replay failed SideEffects related to the view or Field
			for (const context of [field.getBindingContext(), this._view.getBindingContext()].filter(
				(context): context is Context => !!context
			)) {
				const contextPath = context.getPath();
				const failedSideEffects = this._registeredFailedSideEffects[contextPath] ?? [];
				this.unregisterFailedSideEffectsForAContext(contextPath);
				for (const failedSideEffect of failedSideEffects) {
					addSideEffects(context, failedSideEffect);
				}
			}
			await Promise.all(
				Object.values(sideEffectsToExecute).map(async (sideEffectsProperties) =>
					sideEffectsProperties.sideEffects.length === 1
						? this.requestSideEffects(sideEffectsProperties.sideEffects[0], sideEffectsProperties.context)
						: this.requestMultipleSideEffects(sideEffectsProperties.sideEffects, sideEffectsProperties.context)
				)
			);
		} catch (e) {
			Log.debug(`Error while managing Field SideEffects`, e as string);
		}
	}

	/**
	 * Requests the SideEffects for a fieldGroup.
	 *
	 * @param fieldGroupSideEffects Field group sideEffects with its promise
	 * @returns Promise returning true if the SideEffects have been successfully executed
	 */
	private async _requestFieldGroupSideEffects(fieldGroupSideEffects: FieldGroupSideEffectType): Promise<void> {
		this.unregisterFieldGroupSideEffects(fieldGroupSideEffects.sideEffectProperty);
		try {
			await fieldGroupSideEffects.promise;
		} catch (e) {
			Log.debug(`Error while processing FieldGroup SideEffects`, e as string);
			return;
		}
		try {
			const { sideEffects, context, name } = fieldGroupSideEffects.sideEffectProperty;
			if (this.isFieldGroupValid(name, context)) {
				await this.requestSideEffects(sideEffects, context);
			}
		} catch (e) {
			Log.debug(`Error while executing FieldGroup SideEffects`, e as string);
		}
	}

	/**
	 * Saves the validation status of properties related to a field control.
	 *
	 * @param field The field control
	 * @param success Status of the field validation
	 */
	private _saveFieldPropertiesStatus(field: Control, success: boolean): void {
		const sideEffectsMap = this.getFieldSideEffectsMap(field);
		Object.keys(sideEffectsMap).forEach((key) => {
			const { name, immediate, context } = sideEffectsMap[key];
			if (!immediate) {
				const id = this._getFieldGroupIndex(name, context);
				if (success) {
					delete this._fieldGroupInvalidity[id]?.[field.getId()];
				} else {
					this._fieldGroupInvalidity[id] = {
						...this._fieldGroupInvalidity[id],
						...{ [field.getId()]: true }
					};
				}
			}
		});
	}
}

export default SideEffectsControllerExtension;
